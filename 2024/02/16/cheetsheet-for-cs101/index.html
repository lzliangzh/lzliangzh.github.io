<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Introduction to Computing B (yhf) Cheetsheet - 1ntersection</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="1ntersection"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="1ntersection"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="计算概论 B （实验班） 机考材料"><meta property="og:type" content="blog"><meta property="og:title" content="Introduction to Computing B (yhf) Cheetsheet"><meta property="og:url" content="http://lzliangzh.github.io/2024/02/16/cheetsheet-for-cs101/"><meta property="og:site_name" content="1ntersection"><meta property="og:description" content="计算概论 B （实验班） 机考材料"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://lzliangzh.github.io/Users/liangzhong/Library/Application%20Support/typora-user-images/image-20231224171947413.png"><meta property="og:image" content="http://lzliangzh.github.io/Users/liangzhong/Library/Application%20Support/typora-user-images/image-20231226095911170.png"><meta property="og:image" content="http://lzliangzh.github.io/Users/liangzhong/Library/Application%20Support/typora-user-images/image-20231228111846428.png"><meta property="article:published_time" content="2024-02-16T11:24:06.000Z"><meta property="article:modified_time" content="2024-05-10T08:30:31.860Z"><meta property="article:author" content="o0o0o0o"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://lzliangzh.github.io/Users/liangzhong/Library/Application%20Support/typora-user-images/image-20231224171947413.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://lzliangzh.github.io/2024/02/16/cheetsheet-for-cs101/"},"headline":"1ntersection","image":["http://lzliangzh.github.io/Users/liangzhong/Library/Application%20Support/typora-user-images/image-20231224171947413.png","http://lzliangzh.github.io/Users/liangzhong/Library/Application%20Support/typora-user-images/image-20231226095911170.png","http://lzliangzh.github.io/Users/liangzhong/Library/Application%20Support/typora-user-images/image-20231228111846428.png"],"datePublished":"2024-02-16T11:24:06.000Z","dateModified":"2024-05-10T08:30:31.860Z","author":{"@type":"Person","name":"o0o0o0o"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":"计算概论 B （实验班） 机考材料"}</script><link rel="canonical" href="http://lzliangzh.github.io/2024/02/16/cheetsheet-for-cs101/"><link rel="icon" href="/img/favicon.svg"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/favicon.svg" alt="1ntersection" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home/主页</a><a class="navbar-item" href="/archives">Timeline/时间线</a><a class="navbar-item" href="/categories">Categories/分类</a><a class="navbar-item" href="/tags">Tags/标签</a><a class="navbar-item" href="/about">About/关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2024-02-16  <a class="commentCountImg" href="/2024/02/16/cheetsheet-for-cs101/#comment-container"><span class="display-none-class">/2024/02/16/cheetsheet-for-cs101/</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="24d9b13eaaeb4450804447b0433baf48">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>1 小时  <i class="fas fa-pencil-alt"> </i>12.5 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Introduction to Computing B (yhf) Cheetsheet</h1><div class="content"><p>计算概论 B （实验班） 机考材料</p>
<span id="more"></span>

<p>考试地点：机房 6B 座位 71 <a target="_blank" rel="noopener" href="http://cs101.openjudge.cn/">http://cs101.openjudge.cn</a></p>
<h2 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h2><ol>
<li><p><strong>读题</strong>：抄录关键字。写程序前要画出流程图，如标清楚空位从何而来，以防重复或遗漏</p>
</li>
<li><p><strong>debug</strong>：（1）把题目<strong>一字不落</strong>地读 2-3 遍，再看看你的程序；（2）对照测试数据（边界数据）时，走程序流程，笔脑结合，更清晰准确。</p>
</li>
<li><p><strong>时间复杂度</strong>：简单题别想复杂。</p>
<ul>
<li>输入数据 $10^4$，$O(n^2)$ 差不多可以 AC。</li>
<li>如果$10^5$以上，需要考虑 $O(n\log n)$ 方法。</li>
<li>$10^2$ ，可以多重循环，但要注意遍历的顺序。要求按字典序排，则必须从前位往后位遍历。后位的<code>range</code>参数当然可以<strong>与前位依赖</strong>！<code>range(b, a)</code> <code>OJ02810: 完美立方</code></li>
</ul>
</li>
<li><p><strong>math</strong>：Python 支持大整数运算（这点比 C 好太多了），但是注意数很大的时候运算可能会很慢，所以应当用提前取模的办法尽量避免超大数的运算（OJ02706 麦森数）。</p>
<ul>
<li>有除法的时候如果确保整除，用&#x2F;&#x2F;代替&#x2F;（OJ18155 组合乘积）。除法还要注意是否可能出现除以 0 的情况（OJ18223 24 点）</li>
<li>还要再注意：取模 $x % n\in[1,n)$、整除 $x&#x2F;&#x2F;n&#x3D;a…r$ 是向下取整</li>
<li>舍入时注意 round 不是严格意义上的四舍五入，遇到恰好.5 会向偶数舍入。floor 和 ceil 是安全的（当然如果刚好是整数也可能会有精度方面的问题）</li>
<li>float 的等于判断不能用“&#x3D;&#x3D;”，return abs(f1 - f2) &lt;&#x3D; allowed_error 。例如：OJ12065 方程求解，可以 allowed_error &#x3D; 1e-12</li>
</ul>
</li>
<li><p><strong>列表</strong>：反复 remove 很有可能导致超时，这里的办法一般是&#x3D;&#x3D;<strong>开一个真值表先打标记（参见“懒删除”）</strong>&#x3D;&#x3D;</p>
<ul>
<li>遍历列表的时候通常用 for 循环；但是尽量避免一边循环一边删除&#x2F;添加元素。如果必须的话建议改用 while 循环。</li>
<li>匿名函数 lambda x,y:f(x,y) 有时候比单独定义一个函数方便得多（尤其在作为 key 参数的时候）</li>
</ul>
</li>
<li><p><strong>数据预处理</strong>：预处理是“打表”的一种最简单也最常用的方式，预先记录某些信息以便处理问题时直接调用，避免重复计算。常见方法如<strong>记录“前缀和</strong>”以快速得到任意连续段的和（这种方法还可推广到高维的前缀和），利用<strong>差分数组</strong>以方便对连续段的同时更新（一段同时加 x 反映在差分数组上就是头加 x,尾减 x;再用前缀和还原即可），打<strong>下标和值的对应表</strong>以方便查找值在列表中的位置，打<strong>真值表</strong>以方便查找值是否出现过（用集合也可以，但效率稍差），打<strong>计数桶</strong>以方便查找值出现的次数等。</p>
</li>
<li><p><strong>维护适当的信息</strong>：这里所说的信息和预处理中的不同，它们在任务执行过程中<strong>可能改变</strong>。如果维护太多的信息，在更新信息时可能很麻烦；如果维护太少的信息，求解问题时又可能需要复杂的运算。寻找合适的信息来维护，既便于更新，又便于求解（或者说<strong>分摊更新与求解的复杂度</strong>），常常是这类问题的关键。</p>
<p>通常会考虑维护一些<strong>特征量</strong>，例如最大值、最小值、端点&#x2F;边界点、某个特征值出现次数、某个极端位置的量等；这些特征量足够提供求解问题的信息，而又不像全状态那样难以维护。</p>
<p>（这样的题目很多，在很多算法中其实也都有这样的思想；例子暂时想不起来了，大家可以自行补充）</p>
</li>
</ol>
<h2 id="数据的输入与输出"><a href="#数据的输入与输出" class="headerlink" title="数据的输入与输出"></a>数据的输入与输出</h2><p>列表常见输入输出。矩阵的输入输出，见“矩阵”模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表的输入——从空格分隔变成列表（妙招）</span></span><br><span class="line">*value, = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"><span class="comment"># 矩阵的输出——从嵌套列表 变成空格分割</span></span><br><span class="line"><span class="built_in">print</span>( *(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, row)) <span class="keyword">for</span> row <span class="keyword">in</span> mx), sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>): <span class="comment"># 法2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, mx[i][<span class="number">1</span>:-<span class="number">1</span>])))</span><br><span class="line"><span class="comment"># 未明确输入组数时，需要套壳</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>深拷贝列表：<strong>使用列表推导式！或者 deepcopy</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">li2 = [item <span class="keyword">for</span> item <span class="keyword">in</span> li]</span><br></pre></td></tr></table></figure>

<p>整数保留最后$n&#x3D;9$位，小数保留前$n&#x3D;9$位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[i]=(a[i-<span class="number">1</span>]+a[i/<span class="number">2</span>])%<span class="number">1000000000</span>;*//取余是为了只输出最后<span class="number">9</span>位*</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%.9f&#x27;</span> % num)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">zip</span>(a,b))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zipped = <span class="built_in">zip</span>(a,b)     <span class="comment"># 返回一个对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zipped</span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x103abc288</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(zipped)  <span class="comment"># list() 转换为列表</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(a,c))              <span class="comment">#== 元素个数与最短的列表一致 ==!!!!!!!!</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1, a2 = <span class="built_in">zip</span>(*<span class="built_in">zip</span>(a,b))          <span class="comment"># 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(a1)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(a2)</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="基本数据结构的语法技巧"><a href="#基本数据结构的语法技巧" class="headerlink" title="基本数据结构的语法技巧"></a>基本数据结构的语法技巧</h2><p>字符串直接进行&gt;&lt;&#x3D;比较：按照字典序</p>
<h4 id="数、字符"><a href="#数、字符" class="headerlink" title="数、字符"></a>数、字符</h4><p>虚数：<code>complex(real,imagine)</code>或<code>complex(&quot;1+2j&quot;)</code>(不能带空格)</p>
<p><code>str()</code>处理列表等<strong>元素序列</strong>, 不会删去<code>括号</code>和<code>&quot;&quot;</code>; 而<code>repr() </code>方法可以将读取到的格式字符，比如换行符、制表符，转化为其相应的转义字符。</p>
<p><code>eval()</code>函数，执行括号内的字符串</p>
<p><code>tuple(),set(),list()</code>用法相似, <code>list([str])</code>可以拆分字母; 还有<code>frozenset()</code></p>
<p><code>dict()</code> 的使用方法如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(a=<span class="string">&#x27;a&#x27;</span>, b=<span class="string">&#x27;b&#x27;</span>, t=<span class="string">&#x27;t&#x27;</span>)    <span class="comment"># 传入关键字</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;t&#x27;</span>: <span class="string">&#x27;t&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment"># 映射函数方式来构造字典</span></span><br><span class="line">&#123;<span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([(<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="number">3</span>)])  <span class="comment"># 可迭代对象方式来构造字典</span></span><br><span class="line">&#123;<span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>ord()</code> 把字符转换成 ASCII 码，在处理字典序问题时常用。</p>
<p><code>chr()</code> 把 ASCII 码转换成字符。<code>gap = ord(&#39;a&#39;) - ord(&#39;A&#39;)</code></p>
<p><code>hex()</code> 16 进制数，<code>oct()</code> 8 进制数，<code>bin()</code>二进制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">input</span>()</span><br><span class="line">gap = <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ans = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;A&#x27;</span> &lt;= i &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">        ans += <span class="built_in">chr</span>(<span class="built_in">ord</span>(i) + gap)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;a&#x27;</span> &lt;= i &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">        ans += <span class="built_in">chr</span>(<span class="built_in">ord</span>(i) - gap)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ans += i</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(ans))</span><br></pre></td></tr></table></figure>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><code>str.lstrip() / str.rstrip()</code>移除字符串左侧&#x2F;右侧的空白字符。</p>
<p><code>str.find(sub)</code>: 返回子字符串<code>sub</code>在字符串中首次出现的索引，如果未找到，则返回-1。</p>
<p><code>str.replace(old, new)</code>: 将字符串中的<code>old</code>子字符串替换为<code>new</code>。</p>
<p><code>str.startswith(prefix) / str.endswith(suffix)</code>: 检查字符串是否以<code>prefix</code>开头或以<code>suffix</code>结尾。</p>
<p><code>str.isalpha() / str.isdigit() / str.isalnum()</code>: 检查字符串是否全部由字母&#x2F;数字&#x2F;字母和数字组成。</p>
<p>str.title()首字母大写（每个单词），str.lower()&#x2F;upper(）每个字母小&#x2F;大写，str.zfill()自动在前面补 0 补到所需位数</p>
<p><strong>其他</strong></p>
<p>int(str,n)</p>
<p>for key,value in dict.items()</p>
<p>dict.get(key,default)</p>
<p>math.pow(m,n)</p>
<p>math.log(m,n)</p>
<p>lrucache</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="正则表达式语法、ASCII-码"><a href="#正则表达式语法、ASCII-码" class="headerlink" title="正则表达式语法、ASCII 码"></a>正则表达式语法、ASCII 码</h3><table style="border:none;text-align:center;width:auto;margin: 0 auto;">
<tbody>
<tr>
<td style="padding: 6px"><img src="/Users/liangzhong/Library/Application Support/typora-user-images/image-20231224171947413.png" alt="image-20231224171947413" style="zoom:40%;" /></br>正则表达式语法</td><td><img src="/Users/liangzhong/Library/Application Support/typora-user-images/image-20231226095911170.png" alt="image-20231226095911170" style="zoom:20%;" /></br>ASCII 表</td>

</table>

<h3 id="推荐数据结构、常用库"><a href="#推荐数据结构、常用库" class="headerlink" title="推荐数据结构、常用库"></a>推荐数据结构、常用库</h3><p>试试使用桶排序（分区间，分治）、堆、优先队列 quene ||||||| 字典、集合、stack</p>
<p>集合打表能过 。set, frozenset (&#x3D;保证元素唯一性的 tuple) ——set&#x2F;dict 插入都是 O(1)。例外：<strong>用 set&#x2F;dict 处理保证元素唯一性问题。</strong><code>368B. Sereja and Suffixes</code>本来使用集合处理“不同元素”的条件，发现集合的 add 方法有最坏时间复杂度$O(n)$；后用字典依然 TLE 于 test11，询问 GPT 得知：当向字典中添加键值对时，如果<strong>该键值对的哈希值与字典中的其他键值对发生冲突</strong>，将会触发<strong>重新哈希和重新分配内存</strong>的操作。这种情况下，添加键值对的效率可能会降低，并**导致最坏情况下的时间复杂度$O(n)$**。</p>
<p><strong>① 如何去重效率最高？最后再去重！② 实在过不了——使用 DP 思想解题。</strong></p>
<p><code>from itertools import permutation</code></p>
<p><code>from collections import defaltdict</code>：更省事，不用判断 key 有无</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">li = []</span><br><span class="line">heap = []</span><br><span class="line">item = <span class="number">0</span></span><br><span class="line">heapq.heappush(heap, item) <span class="comment"># 向堆中插入元素, 并梳理成堆</span></span><br><span class="line">heapq.heappop(heap) <span class="comment"># 从堆中弹出 最小元素</span></span><br><span class="line">heapq.heapify(li) <span class="comment"># 梳理成堆</span></span><br><span class="line">heapq.heapreplace()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Pop and return the current smallest value, and add the new item.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This is more efficient than heappop() followed by heappush(), and can be</span></span><br><span class="line"><span class="string">    more appropriate when using a fixed-size heap.  **Note that the value</span></span><br><span class="line"><span class="string">    returned may be larger than item!**  That constrains reasonable uses of</span></span><br><span class="line"><span class="string">    this routine unless written as part of a conditional replacement:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        if item &gt; heap[0]:</span></span><br><span class="line"><span class="string">            item = heapreplace(heap, item)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">heapq.nlargest(n, li) <span class="comment"># 弹出列表中最大的 n 个元素</span></span><br><span class="line">heapq.nsmallest(n, li) <span class="comment"># 同理</span></span><br><span class="line">heapq.heappushpop(heap, item) <span class="comment"># Fast version of a heappush followed by a heappop.</span></span><br><span class="line"></span><br><span class="line">数据全反号——大根堆</span><br><span class="line">a, b, c, d = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="comment"># 技巧</span></span><br><span class="line"></span><br><span class="line">插入、弹出：O(logn)，O(logn)，同时稳定维持了堆结构（最大值、最小值）</span><br></pre></td></tr></table></figure>

<h4 id="math"><a href="#math" class="headerlink" title="math"></a>math</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(math.ceil(<span class="number">1.5</span>)) <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(math.<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">3</span>)) <span class="comment"># 8.0</span></span><br><span class="line"><span class="built_in">print</span>(math.<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">2.5</span>)) <span class="comment"># 5.656854249492381</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">9999999</span>&gt;math.inf) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(math.sqrt(<span class="number">4</span>)) <span class="comment"># 2.0</span></span><br><span class="line"><span class="built_in">print</span>(math.log(<span class="number">100</span>,<span class="number">10</span>)) <span class="comment"># 2.0  math.log(x,base) 以base为底，x的对数</span></span><br><span class="line"><span class="comment">#阶乘factorial,组合数comb</span></span><br></pre></td></tr></table></figure>

<h4 id="lru-cache"><a href="#lru-cache" class="headerlink" title="lru_cache"></a>lru_cache</h4><p><code>@lru_cache(maxsize=None)</code>。使用@lru_cache 装饰器时，应注意以下几点：① 被缓存的函数的参数必须是可哈希的，这意味着参数中不能包含可变数据类型，如列表或字典。② 缓存的大小会影响性能，需要根据实际情况来确定合适的大小或者使用默认值。③ 由于缓存中存储了计算结果，可能导致内存占用过大，需谨慎使用。④ 可以是多参数的。</p>
<h4 id="bisect（二分查找）"><a href="#bisect（二分查找）" class="headerlink" title="bisect（二分查找）"></a>bisect（二分查找）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">sorted_list = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>] <span class="comment">#[(0)1, (1)3, (2)5, (3)7, (4)9]</span></span><br><span class="line">position = bisect.bisect_left(sorted_list, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(position)  <span class="comment"># 输出：3，因为6应该插入到位置3，才能保持列表的升序顺序</span></span><br><span class="line"></span><br><span class="line">bisect.insort_left(sorted_list, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted_list)  <span class="comment"># 输出：[1, 3, 5, 6, 7, 9]，6被插入到适当的位置以保持升序顺序</span></span><br><span class="line"></span><br><span class="line">sorted_list=(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(bisect.bisect_left(sorted_list,<span class="number">7</span>))</span><br><span class="line"><span class="built_in">print</span>(bisect.bisect_right(sorted_list,<span class="number">7</span>))</span><br><span class="line"><span class="comment"># 输出：3 6</span></span><br></pre></td></tr></table></figure>

<h4 id="年份-calendar-包"><a href="#年份-calendar-包" class="headerlink" title="年份 calendar 包"></a>年份 calendar 包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> `calendar.month(年, 月)`: 返回一个月份的日历字符串。它接受年份和月份作为参数，并以多行字符串的形式返回该月份的日历。</span><br><span class="line"><span class="number">2.</span> `calendar.calendar(年)`: 返回一个年份的日历字符串。这个函数生成整个年份的日历，格式化为多行字符串。</span><br><span class="line"><span class="number">3.</span> `calendar.monthrange(年, 月)`: 返回两个整数，第一个是该月第一天是周几（<span class="number">0</span>-<span class="number">6</span>表示周一到周日），第二个是该月的天数。</span><br><span class="line"><span class="number">4.</span> `calendar.weekday(年, 月, 日)`: 返回给定日期是星期几。<span class="number">0</span>-<span class="number">6</span>的返回值分别代表星期一到星期日。</span><br><span class="line"><span class="number">5.</span> `calendar.isleap(年)`: 返回一个布尔值，指示指定的年份是否是闰年。</span><br><span class="line"><span class="number">6.</span> `calendar.leapdays(年<span class="number">1</span>, 年<span class="number">2</span>)`: 返回在指定范围内的闰年数量，不包括第二个年份。</span><br><span class="line"><span class="number">7.</span> `calendar.monthcalendar(年, 月)`: 返回一个整数矩阵，表示指定月份的日历。每个子列表表示一个星期；天数为<span class="number">0</span>表示该月份此天不在该星期内。</span><br><span class="line"><span class="number">8.</span> `calendar.setfirstweekday(星期)`: 设置日历每周的起始日。默认情况下，第一天是星期一，但可以通过这个函数更改。</span><br><span class="line"><span class="number">9.</span> `calendar.firstweekday()`: 返回当前设置的每周起始日。</span><br></pre></td></tr></table></figure>

<h4 id="Counter-包、Permutations-包"><a href="#Counter-包、Permutations-包" class="headerlink" title="Counter 包、Permutations 包"></a>Counter 包、Permutations 包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter    <span class="comment"># O(n)</span></span><br><span class="line"><span class="comment"># 创建一个待统计的列表</span></span><br><span class="line">data = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line"><span class="comment"># 使用Counter统计元素出现次数</span></span><br><span class="line">counter_result = Counter(data) <span class="comment"># 返回一个字典类型的东西</span></span><br><span class="line"><span class="comment"># 输出统计结果</span></span><br><span class="line"><span class="built_in">print</span>(counter_result) <span class="comment"># Counter(&#123;&#x27;apple&#x27;: 3, &#x27;banana&#x27;: 2, &#x27;orange&#x27;: 1&#125;)</span></span><br><span class="line"><span class="built_in">print</span>(counter_result[<span class="string">&quot;apple&quot;</span>]) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations <span class="keyword">as</span> per</span><br><span class="line">elements = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">permutations = <span class="built_in">list</span>(per(elements))</span><br></pre></td></tr></table></figure>

<h4 id="default-dict"><a href="#default-dict" class="headerlink" title="default_dict"></a>default_dict</h4><p>defaultdict 是 Python 中 collections 模块中的一种数据结构，它是一种特殊的字典，可以为字典的值提供默认值。当你使用一个不存在的键访问字典时，defaultdict 会自动为该键创建一个默认值，而不会引发 KeyError 异常。</p>
<p>defaultdict 的优势在于它能够简化代码逻辑，特别是在处理字典中的值为可迭代对象的情况下。通过设置一个默认的数据类型，它使得我们不需要在访问字典中不存在的键时手动创建默认值，从而减少了代码的复杂性。</p>
<p>使用 defaultdict 时，首先需要导入 collections 模块，然后通过指定一个默认工厂函数来创建一个 defaultdict 对象。一般来说，这个工厂函数可以是 int、list、set 等 Python 的内置数据类型或者自定义函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="comment"># 创建一个defaultdict，值的默认工厂函数为int(也可以是list -&gt; [0])，表示默认值为0</span></span><br><span class="line">char_count = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="comment"># 统计字符出现次数</span></span><br><span class="line">input_string = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> input_string:</span><br><span class="line">    char_count[char] += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(char_count)  <span class="comment"># 输出 defaultdict(&lt;class &#x27;int&#x27;&gt;, &#123;&#x27;h&#x27;: 1, &#x27;e&#x27;: 1, &#x27;l&#x27;: 2, &#x27;o&#x27;: 1&#125;)</span></span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 累积</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 使用 reduce 计算累积乘积</span></span><br><span class="line">product = functools.reduce(<span class="keyword">lambda</span> x, y: x * y, numbers)</span><br><span class="line"><span class="comment"># ——————————————————————————————————————————————</span></span><br><span class="line"><span class="comment"># 笛卡尔积</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"><span class="comment"># 创建两个可迭代对象</span></span><br><span class="line">colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 生成它们的笛卡尔积</span></span><br><span class="line">cartesian_product = <span class="built_in">list</span>(product(colors, numbers))</span><br><span class="line"><span class="comment"># 创建一个可迭代对象</span></span><br><span class="line">colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="comment"># 生成它们的重复笛卡尔积</span></span><br><span class="line">repeat_cartesian_product = <span class="built_in">list</span>(product(colors, repeat=<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>1）横纵坐标看清楚了！&#x3D;&#x3D;“横 x 纵 y”&#x3D;&#x3D;还是&#x3D;&#x3D;“行 x 列 y”&#x3D;&#x3D;，完全不一样！2）矩阵的字典序比较；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3）输入。是否split看题意！——————①加保护圈输入</span></span><br><span class="line">ipt = [[<span class="string">&#x27;&#x27;</span>]+<span class="built_in">list</span>(<span class="built_in">input</span>())+[<span class="string">&#x27;&#x27;</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(h)]</span><br><span class="line">board = [[<span class="string">&#x27;&#x27;</span>]*<span class="built_in">len</span>(ipt[<span class="number">0</span>])]+ipt+[[<span class="string">&#x27;&#x27;</span>]*<span class="built_in">len</span>(ipt[<span class="number">0</span>])]</span><br><span class="line"><span class="comment">#——————②不加保护圈输入</span></span><br><span class="line">board = [<span class="built_in">list</span>(<span class="built_in">input</span>()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(h)]</span><br></pre></td></tr></table></figure>

<p>4）防止遍历矩阵越界的处理方式</p>
<p>①<strong>对于“仅扫描邻居（最多越界一位）”的题目</strong>：可以考虑加全 0 或全-1 保护圈（<code>508A. Pasha and Pixels</code>,<code>12560: 生存游戏</code>）；</p>
<p>②<strong>对于“任意扫描半径”的题目</strong>：边界检查：for 循环中，range 使用 min&#x2F;max 避免越界(<code>02659:Bomb Game </code>)。感觉到矩阵题目的序号问题犯错频率减少了。</p>
<p>5）矩阵旋转题（Perfect Square）技巧总结</p>
<p>① 用 <code>ord(&#39;a&#39;)</code>转换为 ASCII</p>
<p>② 旋转 90° 均相等 $\Leftrightarrow$ 中心+轴对称</p>
<p>③ 题解中用 <code>~j=-j-1</code> ，<code>~</code> 为按位取反，用于此题表示对称的索引值，是妙用。</p>
<p>【OJ18106: 螺旋矩阵】</p>
<ol>
<li>对于无固定步长、有边界限制的操作，可以通过构造边界（如<code>[-1]</code>），并在操作中添加边界识别步骤，实现“撞南墙则回头”。</li>
<li>有向操作如果有周期，可新建变量<code>d</code> 、方向列表<code>dirct = []</code>，并用<code>d%4</code>(n)表示方位；</li>
<li>有向操作对前景的感知，需要在换向后进行；</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">n, mx</span>):</span><br><span class="line">    v = <span class="number">1</span></span><br><span class="line">    dirct = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>)]</span><br><span class="line">    d = <span class="number">0</span></span><br><span class="line">    r, c = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    fwd = <span class="number">0</span></span><br><span class="line">    n = n*n</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">while</span> fwd == <span class="number">0</span>:</span><br><span class="line">            mx[r][c] = v</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            fwd = mx[r+dirct[d%<span class="number">4</span>][<span class="number">1</span>]][c+dirct[d%<span class="number">4</span>][<span class="number">0</span>]]</span><br><span class="line">            v += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> fwd == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">				        d += <span class="number">1</span></span><br><span class="line">        				fwd = mx[r + dirct[d % <span class="number">4</span>][<span class="number">1</span>]][c + dirct[d % <span class="number">4</span>][<span class="number">0</span>]]</span><br><span class="line">        c += dirct[d % <span class="number">4</span>][<span class="number">0</span>]</span><br><span class="line">        r += dirct[d % <span class="number">4</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> mx</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">mx = [[-<span class="number">1</span>]*(n+<span class="number">2</span>)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    mx.append([-<span class="number">1</span>]+[<span class="number">0</span>]*n+[-<span class="number">1</span>])</span><br><span class="line">mx.append([-<span class="number">1</span>]*(n+<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">mx = fill(n, mx)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, mx[i][<span class="number">1</span>:-<span class="number">1</span>])))</span><br></pre></td></tr></table></figure>

<p>【OJ04133: 垃圾炸弹】</p>
<ol>
<li>在某垃圾周围多大范围内，只要投掷炸弹必能炸掉此垃圾？将此范围内的值 +1 ，表示在此处投放炸弹能炸掉 1 个垃圾（即“此垃圾”）</li>
<li>相似地，考虑其他垃圾。如果某处值为 2，则表示在此处投放炸弹能炸掉 2 个垃圾</li>
<li>遍历整个城市，找到最大值，以及最大值出现了几次。</li>
</ol>
<p>逆向思考，从垃圾思考，而不是从炸弹思考。</p>
<h2 id="动态规划-dp"><a href="#动态规划-dp" class="headerlink" title="动态规划 dp"></a>动态规划 dp</h2><h3 id="递推计数"><a href="#递推计数" class="headerlink" title="递推计数"></a>递推计数</h3><p>这类问题严格来说不算 DP，就是用递推方法解决问题。最简单的譬如斐波那契型数列（OJ02786 Pell 数列，OJ23556 小青蛙跳荷叶），分拆数（OJ04119 复杂的整数划分问题）以及某些不定方程的解数之类的。</p>
<p>稍微难一点的例子譬如 OJ09267 核电站（不太容易建立递推），OJ04150 上机（首先要分析出题目需要满足的条件，转化为一个纯数列问题；其次需要按末位分类进行递推），OJ25573 红蓝玫瑰（需要加上一个数列，记录翻转过的序列所需的操作次数）</p>
<p>这类问题关键往往在于建立递推关系。无法直接建立递推关系时可以考虑<strong>引入若干辅助问题</strong>一并考虑：如果 A 问题能转移到 A 的同构问题和 B 的同构问题之一，而 B 问题也是如此，则同样可以递推解决。</p>
<h3 id="一维-dp"><a href="#一维-dp" class="headerlink" title="一维 dp"></a>一维 dp</h3><p><strong>模型 1：</strong>【最大连续子列和】每一状态两种想法——① 继承，② 重做。选择 max 即可。返回<code>dp[-1]</code></p>
<p><strong>模型 2：</strong>【最长上升子列】每一状态两种想法——① 放入序列（继承前面最大可接项），② 不放入序列，继承前一项。选择 max 即可。返回<code>max(dp)</code></p>
<p>还有一个 nlogn 的算法，非常巧妙（我自己肯定想不到）。维护数组 d,d[i-1]表示<u>长为 i 的递增子序列中末位最小值。</u>可以非常巧妙地维护 dp 数组，需要应用二分查找工具。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">d = [A[<span class="number">0</span>]]</span><br><span class="line">ans = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">    <span class="keyword">if</span> A[i]&gt;d[-<span class="number">1</span>]:</span><br><span class="line">        d.append(A[i])</span><br><span class="line">        ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        index = bisect.bisect_left(d,A[i])</span><br><span class="line">        d[index] = A[i]</span><br></pre></td></tr></table></figure>

<p><strong>模型 2 变式 1：</strong>【最大上升子序列和】把 dp 代表什么换了就行</p>
<p><strong>模型 2 变式 2：</strong>【02711 合唱队列】每一状态两种想法——① 放入序列（继承前面最大**&#x3D;&#x3D;可接项（如何判断是否可接）&#x3D;&#x3D;**），② 不放入序列，继承前一项。返回<code>max(dp)</code></p>
<p><strong>模型 2 变式 3：</strong>【1195C Basketball Exercise】对于每一个相同编号的球员——① 选上面的&#x2F;选下面的，③ 都不选（第一个编号是三种情况）</p>
<h3 id="二维-dp"><a href="#二维-dp" class="headerlink" title="二维 dp"></a>二维 dp</h3><p><strong>模型 3：</strong>【最长公共子列】每一状态两种想法</p>
<p>① 如果是公共的，这个状态的前一状态是两个子列都还没看到这个公共元素的时候，所以是<code>dp[i-1][j-1]+1</code>；</p>
<p>② 如果不是公共的，这个状态的前一状态是两个子列 还没看到这个元素的时候</p>
<p>上面的 dp 分别表示什么？</p>
<p><strong>注：</strong>最长回文子序列问题可化归为最长公共子序列问题：可以证明，A 的最长回文子序列长度等于 A 与 reversed(A)的最长公共子序列长度（并不显然）。例如 OJ01159 Palindrome 就可如此解决。</p>
<p><strong>模型 4：</strong>数塔 dp</p>
<p>① 计算从根节点到第 $i$ 层每一个节点的最大和，并以之替代该节点。</p>
<p>② 已知根节点到第 $i$ 层每一个节点的最大和，又已知第 $i+1$ 层各节点的值，可据此算出第 $i+1$ 层各节点的最大和。</p>
<h3 id="背包-dp"><a href="#背包-dp" class="headerlink" title="背包 dp"></a>背包 dp</h3><h4 id="0-1-背包（原子性，课程学习-etc-）"><a href="#0-1-背包（原子性，课程学习-etc-）" class="headerlink" title="0-1 背包（原子性，课程学习 etc.）"></a>0-1 背包（原子性，课程学习 etc.）</h4><p>&#x3D;&#x3D;<strong>偷商品的一部分（不具有原子性），使用贪心算法</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>有 $n$ 件物品，每件物品的重量为 $w[i],$ 价值为 $c[i]$。现有一个容量为 $V$ 的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。</p>
<p>其中每件物品<strong>有且仅有 1 件</strong>.</p>
</blockquote>
<p>考虑取前 i 个物品用 t 时间所能得到的最大值，枚举第 i 个物品是否取——</p>
<p>A）对于每一种时间情况下，能不能采某一种药，取决于：</p>
<ul>
<li>总时间<code>t</code>是否大于 该药采集所耗时<code>md[i][0]</code></li>
</ul>
<p>如果时间不允许，则继承上一种药，<code>dp[i-1][t]</code></p>
<p>B）对于每一种时间情况下，要不要采某一种药，取决于：</p>
<ul>
<li>不采，即该情况下，总价值为 <code>dp[i-1][t]</code></li>
<li>采，即该情况下，总价值为<code>dp[i-1][t-md[i][0]]+md[i][1]</code></li>
</ul>
<p>何者更大。&#x3D;&#x3D;<strong>注意一定要用 (i+1) * (t+1) 的 dp 表！把 0 算进去</strong>&#x3D;&#x3D;</p>
<p>——来完成转移。注意这里<strong>加上时间参数 t</strong>，因为转移过程中 t 的限定可能会变。“加参数”是 DP 问题中最重要的技巧之一。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp = [<span class="number">0</span>]*T</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(T,time[i]-<span class="number">1</span>,-<span class="number">1</span>): <span class="comment"># 这里是 T+1！！！！</span></span><br><span class="line">        dp[t] = <span class="built_in">max</span>(dp[t],dp[t-time[i]]+value[i])</span><br><span class="line">ans = dp[T]</span><br></pre></td></tr></table></figure>

<p>这里采用“<strong>滚动数组</strong>”的方法将二维数组压缩成一维，是 DP 问题中常用的技巧。这基于选前 i 个物品的状态仅依赖于选前 i-1 个物品的状态。注意<strong>内层循环要倒着遍历</strong>！</p>
<p><strong>输出最佳方案</strong>——如果需要<strong>得到最佳方案</strong>，使用<strong>二维数组</strong>，使用回溯。 (注意: 若使用滚动数组，不能直接利用回溯求解方案)</p>
<p>**&#x3D;&#x3D;初始化技巧&#x3D;&#x3D;**——初始化的 F 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为 -∞ 。</p>
<p>如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为 0，所以初始时状态的值也就全部为 0 了。这个小技巧完全可以推广到其它类型的背包问题。</p>
<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><p>将 0-1 背包中内层循环改为正着遍历即可（这里其实就利用了<strong>先前已经得到的信息</strong>来简化转移：在先前的转移中物品 i 可能已经用过若干次了）</p>
<h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h4><blockquote>
<p>有 $n$ 件物品，每件物品的重量为$w[i],$ 价值为$c[i]$。现有一个容量为 $V$ 的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。</p>
<p><strong>其中每件物品有$s[j]$件.（&#x3D;&#x3D;和 0-1 背包的本质区别&#x3D;&#x3D;）</strong></p>
</blockquote>
<p>最简单的思路是将多个同样的物品看成多个不同的物品，从而化为 0-1 背包。</p>
<ol>
<li><p><strong>前情提要</strong>：二进制优化——用二进制的各位【1, ~2, ~4, ~8, ~16, ~32, ~64, ~128 …】作**&#x3D;&#x3D;桶&#x3D;&#x3D;**，需要时按需凑即可。</p>
<p>——编号最大（如 ~512）这个桶，可能装不满，比如说，装了 100 个。那么，当我需要凑一个大于 100 的数时，优先用这个桶，剩下再用其他桶找零。</p>
</li>
<li><p>二进制优化算法：</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dp = [<span class="number">0</span>]*T</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    all_num = nums[i]</span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> all_num&gt;<span class="number">0</span>:</span><br><span class="line">        use_num = <span class="built_in">min</span>(k,all_num) <span class="comment">#处理最后剩不足2的幂的情形</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(T,use_num*time[i]-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            dp[t] = <span class="built_in">max</span>(dp[t-use_num*time[i]]+use_num*value[i],dp[t])</span><br><span class="line">        k *= <span class="number">2</span></span><br><span class="line">        all_num -= use_nume</span><br></pre></td></tr></table></figure>

<h4 id="变式"><a href="#变式" class="headerlink" title="变式"></a>变式</h4><p>如果需要求出所有可能达到的值，需要用集合更新，状态设计方式不变（OJ01742 coins）</p>
<p>有时候可能需要考虑在给定所选物品的数量的情况下最优化，这时 dp 数组要多带一个数量参数（忘记哪个题了）</p>
<p>有时候背包问题的限制可能更多，需要加更多的参数（OJ04102 宠物小精灵之收服；这个题还有一个要点是<strong>更换参数的选取</strong>。设计 DP 状态时不一定把要求的作为最终结果，有时把<strong>要求的东西作为参数</strong>会更方便）</p>
<p>注：背包问题的 DP 解法需要时间 T 不太大，因为要遍历每个可能的 T。如果 T 很大而物品数量很少，采用 DFS 枚举物品的选法有时是更好的选择。</p>
<h3 id="采用合适的顺序遍历"><a href="#采用合适的顺序遍历" class="headerlink" title="采用合适的顺序遍历"></a>采用合适的顺序遍历</h3><p>某些问题看起来不方便用 DP 解决，因为状态似乎是无序的；但是只要能够找到状态的某个特征量有序，就可以以此为顺序完成 DP（当然这类问题最省脑子的办法参见“记忆化搜索”）</p>
<p>OJ01088 滑雪：要求最长的递降通路长度，状态转移是容易的，但是顺序并不易确定。注意到每步<strong>总是往更低的地方滑</strong>，按<strong>高度</strong>从小到大遍历即可。</p>
<p>OJ01191 棋盘分割：每次分割后棋盘会变小，按<strong>棋盘的大小</strong>从小到大遍历即可（当然这样的话状态比较复杂；这题其实更适合记忆化搜索）</p>
<p>OJ01661 帮助 Jimmy：每次会往下跳，按<strong>高度</strong>从下往上遍历即可；为了减少状态数，可以只考虑<strong>横坐标为某个平台端点</strong>的点（DP 相比记忆化搜索最大的缺陷就在于要设计出能够遍历的状态，而且要尽量减少状态数量）</p>
<p>目前就只能想到这么多了。。。。。。DP 无处不在，肯定还有很多技巧方法没有写到，啥时候想起来再补吧。</p>
<h3 id="dp-技巧"><a href="#dp-技巧" class="headerlink" title="dp 技巧"></a>dp 技巧</h3><p>【CF189A: Cut Ribbon】</p>
<ol>
<li><p><strong>恰好切分</strong>：题目需要 Ribbon 被恰好地切分，因此状态转移方程只能为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = <span class="built_in">max</span>(dp[i-a], dp[i-b], dp[i-c]) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>而不能为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = <span class="built_in">max</span>(<span class="number">1</span>+dp[i-a], <span class="number">2</span>+dp[i-b], <span class="number">3</span>+dp[i-c], dp[i-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>后者意味着：长度 i 的 Ribbon <strong>继承</strong> 长度 i-1 的 Ribbon 的切法，即有<strong>边角料</strong>。</p>
</li>
<li><p>注意 Python 中负数列表索引不报错，被认为是列表末尾。</p>
</li>
<li><p><strong>初始化</strong>：以 $-\infty$ 初始化列表非首项，是为了保证：</p>
<ul>
<li>特别地，在 Ribbon 达到可被切分的最小长度前，Ribbon 的切分不会被考虑；</li>
<li>对于某一特定长度，如果不存在一种切法，使得 Ribbon 被恰好地切分，那么该长度的 Ribbon 永远不会成为某一 Ribbon 的子 Ribbon，参与切分方法的考虑。</li>
</ul>
</li>
<li><p>特别地，<code>-inf</code>在 Python 中表示 $-\infty$ 。</p>
</li>
</ol>
<h2 id="深搜-DFS"><a href="#深搜-DFS" class="headerlink" title="深搜 DFS"></a>深搜 DFS</h2><p><strong>&#x3D;&#x3D;枚举&#x3D;&#x3D;所有完整路径，以遍历所有情况</strong>。不适合解决【障碍物少、空位多 → 路径可能性极多】的情况。</p>
<p>递归深度调整——<code>sys.setrecursionlimit(1 &lt;&lt; 30)</code></p>
<p>步骤：</p>
<ol>
<li><p>从起点开始走；</p>
</li>
<li><p>遇到&#x3D;&#x3D;<strong>分岔路</strong>&#x3D;&#x3D;进行标记，<code>for i in range(n)</code>，沿着第<code>i</code>个分岔路继续前进；（分岔？例如 <code>if...else...</code>, <code>max[A, B]</code>, <code>min[C, D]</code>。有分叉都能深搜。）</p>
</li>
<li><p>遇到死路【&#x3D;&#x3D;<strong>递归边界</strong>&#x3D;&#x3D;】则<code>return</code>上一个分岔路口（&#x3D;&#x3D;<strong>回溯</strong>&#x3D;&#x3D;），<code>i--&gt;i+1</code>，下一个分叉路继续探寻，<strong>标记</strong>新建数组或在已有点上。</p>
</li>
<li><p>如果达到终点，就<code>print(ans); return</code>。</p>
</li>
</ol>
<p>如果<strong>搜索超时，可以考虑进行剪枝，以避免搜索不满足约束条件的路径</strong>。</p>
<p>这样说来，&#x3D;&#x3D;<strong>递归中的递归式就是岔道口，而递归边界就是死胡同</strong>&#x3D;&#x3D;，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#示例代码：19930寻宝</span></span><br><span class="line">counter = -<span class="number">1</span></span><br><span class="line">ans = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">global</span> mx, counter, m, n, ans</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> y &gt;= m <span class="keyword">or</span> x &gt;= n <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> mx[y][x] == <span class="number">2</span>: <span class="comment"># 遇到递归边界，回到上一个分岔路口。</span></span><br><span class="line">        counter -= <span class="number">1</span> <span class="comment"># 步数记得回溯！🤓</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> mx[y][x] == <span class="number">1</span>:</span><br><span class="line">        ans.append(counter)</span><br><span class="line">        counter -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    steps = [(<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">    mx[y][x] = <span class="number">2</span> <span class="comment"># 标记岔路口，免得又探回头😡</span></span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> steps: <span class="comment"># 沿着不同的分叉路，继续前进！💪🏻</span></span><br><span class="line">        dfs(x+step[<span class="number">0</span>], y+step[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 回溯</span></span><br><span class="line">    mx[y][x] = <span class="number">0</span></span><br><span class="line">    counter -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">mx = []</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    mx.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">dfs(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># 从起点开始走</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(ans) <span class="keyword">if</span> ans != [] <span class="keyword">else</span> <span class="string">&#x27;NO&#x27;</span>)</span><br></pre></td></tr></table></figure>

<img src="/Users/liangzhong/Library/Application Support/typora-user-images/image-20231228111846428.png" alt="image-20231228111846428" style="zoom:30%;" />

<h2 id="广搜-BFS【图转树】"><a href="#广搜-BFS【图转树】" class="headerlink" title="广搜 BFS【图转树】"></a>广搜 BFS【图转树】</h2><p>① 定义队列 q，并将起点 s 入队。</p>
<p>② 写一个 while 循环，循环条件是队列 q 非空。</p>
<p>③ 在 while 循环中，先取出队首元素 top，然后访问它（访问可以是任何事情，例如将其输出）。访问完后将其出队。</p>
<p>④ 将 top 的下一层结点中所有&#x3D;&#x3D;<strong>未曾入队</strong>&#x3D;&#x3D;的结点入队，并标记它们的层号为 now 的层号加 1，同时设置这些入队的结点已入过队。</p>
<p>⑤ 返回 ② 继续循环。</p>
<p><strong>强调</strong>：在 BFS 中设置的 <code>inq</code> 数组【<code>inq</code>数组一般开到“遍历”的所有可能】的含义是&#x3D;&#x3D;<strong>判断结点是否已入过队</strong>&#x3D;&#x3D;，而不是<strong>结点是否已被访问</strong>。区别在于:如果设置成是否已被访问，有可能在某个结点正在队列中、但还未访问时由于其他结点可以到达它而将这个结点再次入队，导致很多结点反复入队，计算量大大增加。因此 BFS 中让每个结点只入队一次，故需要设置 inq 数组的含义为<strong>结点是否已入过队</strong>而非结点是否已被访问。</p>
<p>入队了一定会被访问，因此要从入队开始卡人，才及时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例代码：02802小游戏伪AC代码，只计算了步数，未换算成线段数</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dx = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">dy = [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>():</span><br><span class="line">    <span class="keyword">global</span> x1, y1, x2, y2, board, w, h</span><br><span class="line">    r, c = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">    inq = [[<span class="literal">False</span> <span class="keyword">for</span> cc <span class="keyword">in</span> <span class="built_in">range</span>(c)] <span class="keyword">for</span> rr <span class="keyword">in</span> <span class="built_in">range</span>(r)] <span class="comment"># “入过队”标记们</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    q = deque()</span><br><span class="line">    q.append((x1, y1))</span><br><span class="line">    inq[y1][x1] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    step = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(q) == <span class="number">0</span>: <span class="keyword">return</span> <span class="string">&#x27;impossible&#x27;</span> <span class="comment"># 没有“下一级节点”了，证明遍历完还不合题意，没法子了</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">            top = q.popleft() <span class="comment"># 一个步骤，要遍拿出这一级的所有节点才算</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                next_x = top[<span class="number">0</span>] + dx[i]</span><br><span class="line">                next_y = top[<span class="number">1</span>] + dy[i]</span><br><span class="line">                <span class="keyword">if</span> (next_x, next_y) == (x2, y2): <span class="keyword">return</span> step <span class="comment">#“下一级”符合题意了，return！</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= next_x &lt; w+<span class="number">2</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= next_y &lt; h+<span class="number">2</span> <span class="keyword">and</span> board[next_y][next_x] != <span class="string">&#x27;X&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> inq[next_y][next_x]:</span><br><span class="line">                    inq[next_y][next_x] = <span class="literal">True</span> <span class="comment"># “下一级”虽然不合题意，但还没遍历完，加到q里，待下一步考量！</span></span><br><span class="line">                    q.append((next_x, next_y))</span><br><span class="line">        step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    w, h = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">if</span> w == h == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">    ipt = [[<span class="string">&#x27;&#x27;</span>]+<span class="built_in">list</span>(<span class="built_in">input</span>())+[<span class="string">&#x27;&#x27;</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(h)]</span><br><span class="line">    <span class="comment">#print(ipt[0])</span></span><br><span class="line">    board = [[<span class="string">&#x27;&#x27;</span>]*<span class="built_in">len</span>(ipt[<span class="number">0</span>])]+ipt+[[<span class="string">&#x27;&#x27;</span>]*<span class="built_in">len</span>(ipt[<span class="number">0</span>])]</span><br><span class="line">    <span class="comment">#print(board)</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x1, y1, x2, y2 = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="keyword">if</span> x1 == y1 == x2 == y2 == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(bfs())</span><br></pre></td></tr></table></figure>

<h2 id="二分查找-二分法-双指针"><a href="#二分查找-二分法-双指针" class="headerlink" title="二分查找&#x2F;二分法&#x2F;双指针"></a>二分查找&#x2F;二分法&#x2F;双指针</h2><p>二分查找使用条件：**&#x3D;&#x3D;① 有序序列；&#x3D;&#x3D;**② 数据量适中，太小提升少，太大 MLE；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">bisect.bisect_left(li, <span class="number">4</span>, lo, hi, key)</span><br><span class="line">bisect.bisect_right(li, <span class="number">4</span>, lo, hi, key) <span class="comment"># = bisect.bisect()</span></span><br><span class="line">bisect.insort_left() <span class="comment"># 参数相似</span></span><br><span class="line">bisect.insort_right() = <span class="comment">#bisect.insort()</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(\log n)$。二分查找代码实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">num = <span class="number">5</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">arr, num</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(arr)-<span class="number">1</span></span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; arr[mid]:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> num &gt; arr[mid]:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># arr[mid] == num</span></span><br><span class="line">            <span class="comment"># print(f&#x27;查找了&#123;counter&#125;次&#x27;)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&#x27;值<span class="subst">&#123;num&#125;</span>已找到，索引值为<span class="subst">&#123;mid&#125;</span>&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;查找了<span class="subst">&#123;counter&#125;</span>次&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;值<span class="subst">&#123;num&#125;</span>未找到&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(binary_search(arr, num))</span><br></pre></td></tr></table></figure>

<p><strong>双指针</strong></p>
<p>本质还是遍历。但通过双指针，证明好了，可以</p>
<p><strong>左右指针</strong>：需要两个指针，一个指向开头，一个指向末尾，然后向中间遍历，直到满足条件或者两个指针相遇。</p>
<p><strong>快慢指针</strong>：需要两个指针，开始都指向开头，根据条件不同，快指针走得快，慢指针走的慢，直到满足条件或者快指针走到结尾。</p>
<p><strong>后序指针</strong>：常规指针操作是从前向后便利，对于合并和替换类型题，防止之前的数据被覆盖，双指针需从后向前便利。</p>
<p><strong>&#x3D;&#x3D;记忆口诀：左右指针中间夹，快慢指针走到头，后序指针往回走&#x3D;&#x3D;</strong></p>
<p>做形如 n 数之和——双指针！</p>
<p>思路：</p>
<p>注意点</p>
<ol>
<li><p>while 的条件不会继承。大 while 内的小 while 还得限制 L&lt;R，否则会一下子就不满足大 while 条件，可能导致报错（IndexError）。数据<code>0 0 0</code></p>
</li>
<li><p>做好输出：就算没法走<code>arr[i] &gt; 0</code>的输出（考虑全 0），也得输出当前累计的<code>counter</code>值。数据<code>0 0 0 0</code></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三数之和</span></span><br><span class="line">arr = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">n = <span class="built_in">len</span>(arr)</span><br><span class="line">arr.sort()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Sum3</span>(<span class="params">arr, n</span>):</span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line"><span class="comment"># 无需特判</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> counter</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> arr[i] == arr[i-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        L = i+<span class="number">1</span></span><br><span class="line">        R = n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> L&lt;R:</span><br><span class="line">            <span class="keyword">if</span> arr[i] + arr[L] + arr[R] == <span class="number">0</span>:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> arr[L] == arr[L+<span class="number">1</span>]:</span><br><span class="line">                    L += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> L &lt; R <span class="keyword">and</span> arr[R] == arr[R-<span class="number">1</span>]:</span><br><span class="line">                    R -= <span class="number">1</span></span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> arr[i] + arr[L] + arr[R] &gt; <span class="number">0</span>:</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Sum3(arr, n))</span><br></pre></td></tr></table></figure>

<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>【OJ02431 expedition】这个题就需要一些<strong>思维上的转换</strong>了。直观上看应该每次加尽量多的油，但是在哪个范围里选最多呢？这里有一种看法：每次路过一个加油站就把油全拿上，但是不加；<strong>每次没油的时候再挑一桶加</strong>，这个时候挑的一定是目前手上最多的，于是问题迎刃而解。</p>
<p>这种<strong>“延迟操作</strong>”的思考方式在某些时候是很有用的。</p>
<p>【26971 分发糖果】：两次遍历方法，使得序列既满足“左规则”，又满足“右规则”</p>
<ol>
<li>从左往右遍历，使得对于 cds[i]，其与右边的元素 cds[i+1] 的关系总符合题意“谁大就谁分的多”。但要注意，此时对于 cds[i]，其与左边的元素不一定满足题意。</li>
<li>从右往左遍历，使得对于 cds[i]，其与左边的元素 cds[i-1] 的关系总符合题意“谁大就谁分的多”</li>
</ol>
<p>【CF1000B: Light It Up（前缀和思想）】：有一台灯，这个灯在时间为$0$时打开，$m$时关闭，在$0$到$m$这段时间内有$n$个时间点灯的状态会改变（即开变关，关变开），在哪里插个点，使得这个灯亮着的时间最大。1）如果不插点，亮着的时间就是 所有 $<a href="i=2k">i, i+1</a>$ 的区间长度和。</p>
<p><strong>困难在于：如何解决“插点改变状态”后，开、关操作对应索引值的奇偶性逆转的问题。</strong></p>
<p>在插点后，“开”区间平移变为 $<a href="i=2k">i+1,i+2</a>$ ，并增加 $<a href="i=2k">插点, i</a>$ 。如果对于每次插点操作，都要重新计算“开”区间总长度，时间复杂度是 $O(n^2)$，对于 $n&#x3D;10^5$ 的数量级无法承受。</p>
<p><strong>解决方法：前缀和思想</strong>。思路是，新建“前（后）缀和”数组 <code>pix = []</code>：</p>
<ul>
<li><code>pix</code>中索引为 $i &#x3D; 2k(k\in\Z^+)$ 的值，代表从前往后累计的，所有 $<a href="i=2k">i, i+1</a>$ 的区间长度和；</li>
<li><code>pix</code>中索引为 $i &#x3D; 2k-1(k\in\Z^+)$ 的值，代表从后往前累计的，所有 $<a href="i=2k-1">i, i+1</a>$ 的区间长度和。</li>
</ul>
<p>这样，对于每次插点操作（插在 <strong>索引值为奇数 $j$ 的项</strong> 前面），“开”区间总长度则可用 $O(1)$ 的操作计算，公式为：</p>
<p>$$<br>\text{len} &amp;&#x3D;&amp; \text{pix}[j-1] + \text{pix}[j+2] + [插点,i] \<br> &amp;&#x3D;&amp; \text{pix}[j-1] + \text{pix}[j+2] +(\text{tds}[j+1]-\text{tds}[j]-1)<br>$$</p>
<ul>
<li>为什么是 j+2 不是 j ？因为要挖掉 插点 所在的那个区间，同时增加 $<a href="i=2k">插点, i</a>$ 。</li>
</ul>
<p>【18164 剪绳子（哈夫曼编码 Huffman 思想）】：剪绳子就是拼绳子，在一定的操作次数下，每次选择最短(<code>heappop</code>)的两段绳子拼起来，拼后压回绳组(<code>heappush</code>）。</p>
<p><strong>&#x3D;&#x3D;以谁为参照系，遍历谁？？？&#x3D;&#x3D;</strong></p>
<hr>
<h3 id="区间覆盖问题"><a href="#区间覆盖问题" class="headerlink" title="区间覆盖问题"></a>区间覆盖问题</h3><h4 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h4><p>给出一堆区间，要求<strong>合并</strong>所有<strong>有交集的区间</strong> （端点处相交也算有交集）。最后问合并之后的<strong>区间个数</strong>。</p>
<p>【<strong>步骤一</strong>】：按照区间<strong>左端点</strong>从小到大排序:</p>
<p>【<strong>步骤二</strong>】：维护前面区间中最右边的端点为<code>ed</code>。从前往后枚举每一个区间，判断是否应该将当前区间视为新区间。</p>
<p>假设当前遍历到的区间为第<code>i</code>个区间 $[l_i, r_i]$，有以下两种情况：</p>
<ul>
<li>$l_i\le ed$：说明当前区间与前面区间<strong>有交集</strong>。因此<strong>不需要</strong>增加区间个数，但需要设置 $ed&#x3D;\max(ed, r_i)$。</li>
<li>$l_i\ge ed$：说明当前区间与前面<strong>没有交集</strong>。因此<strong>需要</strong>增加区间个数，并设置 $ed&#x3D;\max(ed, r_i)$。</li>
</ul>
<h4 id="选择不相交区间"><a href="#选择不相交区间" class="headerlink" title="选择不相交区间"></a>选择不相交区间</h4><p>给出一堆区间，要求选择<strong>尽量多</strong>的区间，使得这些区间<strong>互不相交</strong>，求可选取的区间的<strong>最大数量</strong>。这里端点相同也算有重复。</p>
<p>【<strong>步骤一</strong>】：按照区间<strong>右端点</strong>从小到大排序。</p>
<p>【<strong>步骤二</strong>】：从前往后依次枚举每个区间。</p>
<p>假设当前遍历到的区间为第<code>i</code>个区间 $[l_i,r_i]$ ，有以下两种情况：</p>
<ul>
<li>$l_i\le ed$：说明当前区间与前面区间有交集。因此直接跳过。</li>
<li>$l_i&gt;ed$：说明当前区间与前面没有交集。因此选中当前区间，并设置 。</li>
</ul>
<h4 id="区间选点"><a href="#区间选点" class="headerlink" title="区间选点"></a>区间选点</h4><p>给出一堆区间，取<strong>尽量少</strong>的点，使得每个区间内<strong>至少有一个点</strong>（不同区间内含的点可以是同一个，位于区间端点上的点也算作区间内）。</p>
<p>这个题可以转化为上一题的<strong>求最大不相交区间</strong>的数量。</p>
<p>对于这些<strong>最大的不相交区间</strong>，肯定是每个区间都需要选出一个点。而其他的区间都是和这些选出的区间有重复的，我们只需要把点的位置选在<strong>重合</strong>的部分即可。</p>
<p>也可以换一种思路：</p>
<p>我们将区间按照<strong>右端点</strong>从小到大排序，这时我们应该尽量选择<strong>当前区间最右边的点</strong>。</p>
<p>因为最右边的点可能和下面的其他区间重复，所以至少不比选择区间靠前位置的点差。</p>
<p>所以，最后的解法与选择不相交区间问题解法完全一样。</p>
<h4 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title="区间覆盖"></a>区间覆盖</h4><p>给出一堆区间和一个目标区间，问最少选择多少区间可以<strong>覆盖</strong>掉题中给出的这段目标区间。</p>
<p>【<strong>步骤一</strong>】：按照区间左端点从小到大排序。</p>
<p>【<strong>步骤二</strong>】：<strong>从前往后</strong>依次枚举每个区间，在所有能覆盖当前目标区间起始位置<code>start</code>的区间之中，选择<strong>右端点</strong>最大的区间。</p>
<p>假设右端点最大的区间是第$i$个区间，右端点为 $r_i$，</p>
<p>最后将目标区间的 start 更新成 $r_i$</p>
<h4 id="区间分组"><a href="#区间分组" class="headerlink" title="区间分组"></a>区间分组</h4><p><strong>区间分组</strong>问题大概题意就是：给出一堆区间，问最少可以将这些区间分成多少组，使得每个组内的区间互不相交。</p>
<p>【<strong>步骤一</strong>】：按照区间左端点从小到大排序。</p>
<p>【<strong>步骤二</strong>】：从<strong>前往后</strong>依次枚举每个区间，判断当前区间能否被放到某个现有组里面。</p>
<p>（即判断是否存在某个组的右端点在当前区间之中。如果可以，则不能放到这一组）</p>
<p>假设现在已经分了 $m$ 组了，第 $k$ 组最右边的一个点是 $r_k$，当前区间 $i$ 的范围是 $[L_i, R_i]$。则：</p>
<blockquote>
<p>如果 $L_i\le r_k$ ，则表示第 $i$ 个区间无法放到第 $k$ 组里面。</p>
<p>反之，如果 $L_i&gt;r_k$， 则表示可以放到第 $k$ 组。</p>
</blockquote>
<ul>
<li>如果所有 $m$ 个组里面没有组可以接收当前区间，则当前区间新开一个组，并把自己放进去。</li>
<li>如果存在可以接收当前区间的组 $k$ ，则将当前区间放进去，并更新当前组的 。</li>
</ul>
<p><strong>注意：</strong></p>
<p>为了能快速的找到能够接收当前区间的组，我们可以使用<strong>优先队列 （小顶堆）</strong>。</p>
<p>优先队列里面记录每个组的右端点值，每次可以在 的时间拿到右端点中的的最小值。</p>
<hr>
<p>【27104 世界杯只因】<strong>：如何以尽可能少的摄像头，覆盖尽可能多的区域。</strong></p>
<p>初始化 结果数组 各处均为 0。</p>
<ul>
<li>结果数组每一位的值，表示 范围要覆盖到这里所需要的最少摄像头数目；</li>
<li>初始化的 0 表示 此处无法被覆盖到。</li>
</ul>
<p>每一次：</p>
<p>对于第一个没被覆盖到的点，<strong>寻找一个摄像头，使得这个摄像头：</strong></p>
<ol>
<li>能覆盖到这个点 <strong>（&#x3D;&#x3D;不一定在这个点上！&#x3D;&#x3D;）</strong></li>
<li>最省心——能覆盖尽可能多的区域（即<strong>右边界最大</strong>），这样下一次就可以节省摄像头</li>
</ol>
<p>找到这个摄像头后，把这个摄像头覆盖的所有区域的值 都更新为所需的最少的摄像头数目。</p>
<p>下一次寻找没被覆盖到的点时，从这个摄像头的右边界开始寻找即可。</p>
<p><strong>这个算法对于任给一族区间要找最小覆盖的问题都对。</strong></p>
<p>【Radar Installation】：我们可以逆向思维来贪心。首先我们已经知道一个贪心模板——最小区间覆盖，且这题也很像它，那么我们就把这题转成这个模板。</p>
<p>我们发现可以覆盖某个小岛的雷达在海岸线上的坐标呈一条线分布。<br>那么我们就把这一段线看成一段区间，用雷达覆盖所有区间。<br>由勾股定理得第 $i$ 个小岛的区间为：</p>
<p>$(x−sqrt(d∗d−y_i∗y_i),x+sqrt(d∗d−y_i∗y_i))$</p>
<p>那么我们再按最小区间覆盖的做法，将右端点从小到大排序，然后取点，结束。</p>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p><strong>素数筛法——欧拉筛</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pre</span>(<span class="params">n</span>):</span><br><span class="line">    pri = []</span><br><span class="line">    not_prime = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> not_prime[i]:</span><br><span class="line">            pri.append(i)</span><br><span class="line">        <span class="keyword">for</span> pri_j <span class="keyword">in</span> pri:</span><br><span class="line">            <span class="keyword">if</span> i * pri_j &gt; n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            not_prime[i * pri_j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i % pri_j == <span class="number">0</span>:</span><br><span class="line">                <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      i % pri_j == 0</span></span><br><span class="line"><span class="string">      换言之，i 之前被 pri_j 筛过了</span></span><br><span class="line"><span class="string">      由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被</span></span><br><span class="line"><span class="string">      pri_j 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break</span></span><br><span class="line"><span class="string">      掉就好了</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(pri)</span><br></pre></td></tr></table></figure>

<p><code>OJ01218:THE DRUNK JAILER</code>：能够拨动奇数次的开关，必然是因子个数为奇数的开关。而因子个数为奇数，一定是完全平方数。因为因子是成对出现的，只有完全平方数才会有一个独自的因子。如 $36\to(1,36),(2,18),(3,12),(4,9),6&#x3D;7$ 个因子。</p>
<p><code>OJ01008: Maya Calendar</code>：注意取模 $\in[0,除数-1]$，而题中日历 $\in[1,除数]$</p>
<hr>
<p>defaultdict 使用方法</p>
<p>assignment9 好多没做，矩阵卷积运算</p>
<p>01922: Ride to School<a target="_blank" rel="noopener" href="http://cs101.openjudge.cn/practice/01922/">http://cs101.openjudge.cn/practice/01922/</a></p>
<p>思路：</p>
<p>虽然是追及问题，但注意时间变化的连续性。不可用 t +&#x3D; 1 模拟时间变化。</p>
<p>向上取整 <code>math.ceil()</code></p>
<p><strong>&#x3D;&#x3D;Charley 一定和某人一起到。&#x3D;&#x3D;</strong></p>
<p>脑筋急转弯</p>
<p>买学区房接收数据</p>
<p>pairs &#x3D; [i[1:-1] for i in input().split()]<br>distances &#x3D; [ sum(map(int,i.split(‘,’))) for i in pairs]</p>
<p><a target="_blank" rel="noopener" href="http://cs101.openjudge.cn/practice/19963">http://cs101.openjudge.cn/practice/19963</a></p>
<p>递归方法的技巧——想要一直往前冲，不回头，就把 n 弄成全局变量，而非函数的参数。【波兰表达式】</p>
<p>题目数据没说保序，就必须排序！</p>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p><code>OJ02707: 求一元二次方程的根</code></p>
<p><code>OJ4146：数字方格</code>：math</p>
<p><code>OJ02746: 约瑟夫问题</code></p>
<p>CF96A</p>
<p>![image-20231209210959489](&#x2F;Users&#x2F;liangzhong&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20231209210959489.png)</p>
<hr>
<p>树状数组、线段树（期中阶段の补充）</p>
<p>确实，dijksta 可以套 bfs 的堆写法模板</p>
<p><strong>&#x3D;&#x3D;dfs——把传入数据写到 def 上？TA-Hu Yang&#x3D;&#x3D;</strong></p>
<p>&#x3D;&#x3D;<strong>dp——模版？</strong>&#x3D;&#x3D;</p>
<p>优先队列？？？？——顺序会改变！</p>
<p>from colletions import deque，双端队列，两边出数都快</p>
<p>背包问题 dp 模版！！！</p>
<p>CF230B、DrunkJailor</p>
<p>宽搜——heapq!!!&#x2F;&#x2F;quene!!!(先进先出)</p>
<p>宽搜用字典记录也可，字典套 tuple，vis&#x3D;dict()</p>
<p><code>all()</code></p>
<table>
<thead>
<tr>
<th>作业</th>
<th>没做出来的题目</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>装箱问题</td>
</tr>
<tr>
<td>4</td>
<td>CF1364A: XXXXX、OJ04146: 数字方格</td>
</tr>
<tr>
<td>5</td>
<td>12559: 最大最小整数 v0.3、230B. T-primes</td>
</tr>
<tr>
<td>6</td>
<td>生存游戏</td>
</tr>
<tr>
<td>7</td>
<td>1793C. Dora and Search、368B. Sereja and Suffixes</td>
</tr>
<tr>
<td>8 (Nov 月考)</td>
<td>23566: 决战双十一</td>
</tr>
<tr>
<td>9</td>
<td>几乎没做</td>
</tr>
<tr>
<td>A</td>
<td>认真看， <a target="_blank" rel="noopener" href="https://codeforces.com/contest/455/problem/A">https://codeforces.com/contest/455/problem/A</a></td>
</tr>
<tr>
<td>B√</td>
<td>摆动数列</td>
</tr>
<tr>
<td>C√</td>
<td>乌鸦坐飞机——装箱问题</td>
</tr>
<tr>
<td>D√</td>
<td>over，最多差一个 2050 成绩计算</td>
</tr>
</tbody></table>
<p>打魔兽</p>
<p>set dict 双指针 能过</p>
<p>回溯</p>
<p>全排列、八皇后，生成方案，遍历方案</p>
<p>装箱——题解</p>
<p>Numpy×</p>
<h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><h3 id="OJ25353-排队"><a href="#OJ25353-排队" class="headerlink" title="OJ25353: 排队"></a>OJ25353: 排队</h3><p>Greedy, <a target="_blank" rel="noopener" href="http://cs101.openjudge.cn/practice/25353/">http://cs101.openjudge.cn/practice/25353/</a></p>
<p>有 $N$ 名同学从左到右排成一排，第 $i$ 名同学的身高为 $h_i$。现在张老师想改变排队的顺序，他能进行任意多次（包括 0 次）如下操作：</p>
<p>- 如果两名同学相邻，并且他们的身高之差不超过 $D$，那么老师就能交换他俩的顺序。</p>
<p>请你帮张老师算一算，通过以上操作，字典序最小的所有同学（从左到右）身高序列是什么？</p>
<p>输入</p>
<p>第一行包含两个正整数 $N, D (1≤N≤10^5, 1≤D≤10^9)$。<br>接下去 $N$ 行，每行一个正整数 $h_i (1\le h_i \le 10^9)$ 表示从左到右每名同学的身高。</p>
<p>输出</p>
<p>输出 $N$ 行，第 $i$ 行表示答案中第 $i$ 名同学的身高。</p>
<p>样例输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">7</span><br><span class="line">7</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>样例输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">7</span><br><span class="line">7</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>提示</p>
<p>【样例解释】<br>一种交换位置的过程如下：<br><code>7 7 3 6 2-&gt; 7 7 6 3 2-&gt; 7 7 6 2 3-&gt; 7 6 7 2 3-&gt; 6 7 7 2 3</code></p>
<h3 id="OJ01017-装箱问题"><a href="#OJ01017-装箱问题" class="headerlink" title="OJ01017: 装箱问题"></a>OJ01017: 装箱问题</h3><p>greedy, <a target="_blank" rel="noopener" href="http://cs101.openjudge.cn/practice/01017">http://cs101.openjudge.cn/practice/01017</a></p>
<p>一个工厂制造的产品形状都是长方体，它们的高度都是 h，长和宽都相等，一共有六个型号，他们的长宽分别为 1*1, 2*2, 3*3, 4*4, 5*5, 6*6。这些产品通常使用一个 6*6*h 的长方体包裹包装然后邮寄给客户。因为邮费很贵，所以工厂要想方设法的减小每个订单运送时的包裹数量。他们很需要有一个好的程序帮他们解决这个问题从而节省费用。现在这个程序由你来设计。</p>
<p><strong>输入</strong>：输入文件包括几行，每一行代表一个订单。每个订单里的一行包括六个整数，中间用空格隔开，分别为 1<em>1 至 6</em>6 这六种产品的数量。输入文件将以 6 个 0 组成的一行结尾。</p>
<p><strong>输出</strong>：除了输入的最后一行 6 个 0 以外，输入文件里每一行对应着输出文件的一行，每一行输出一个整数代表对应的订单所需的最小包裹数。</p>
<p>解题思路：4*4, 5*5, 6*6 这三种的处理方式较简单，就是每一个箱子至多只能有其中 1 个，根据他们的数量添加箱子，再用 2*2 和 1*1 填补。1*1, 2*2, 3*3 这些就需要额外分情况讨论，若有剩余的 3*3,每 4 个 3*3 可以填满一个箱子，剩下的 3*3 用 2*2 和 1*1 填补装箱。剩余的 2*2，每 9 个可以填满一个箱子，剩下的与 1*1 一起装箱。最后每 36 个 1*1 可以填满一个箱子，剩下的为一箱子。</p>
<p>样例输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 4 0 0 1</span><br><span class="line">7 5 1 0 0 0</span><br><span class="line">0 0 0 0 0 0</span><br></pre></td></tr></table></figure>

<p>样例输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>来源：Central Europe 1996</p>
<p>【张概论，中国语言文学系，2023 年秋】 &#x3D;&#x3D;（请改为同学的姓名、院系）&#x3D;&#x3D;</p>
<p>思路：&#x3D;&#x3D;（请改为同学的思路和代码）&#x3D;&#x3D;</p>
<p>用时至少 3 个半天（早上&#x2F;中午&#x2F;晚上）</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## OJ1017: 装箱问题</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">num_2</span>(<span class="params">li</span>):</span><br><span class="line">    rest_3_2 = [<span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">    rest_3_1 = [<span class="number">0</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line">    rest_more_2 = [<span class="number">0</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">    space_2_4 = li[<span class="number">4</span>] * <span class="number">5</span></span><br><span class="line">    space_2_3 = rest_3_2[li[<span class="number">3</span>] % <span class="number">4</span>]</span><br><span class="line">    <span class="keyword">if</span> li[<span class="number">2</span>] - space_2_4 &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>, ((space_2_4 - li[<span class="number">2</span>]) + space_2_3) * <span class="number">4</span>]</span><br><span class="line">    <span class="keyword">elif</span> li[<span class="number">2</span>] - space_2_4 &gt; <span class="number">0</span> &gt;= li[<span class="number">2</span>] - (space_2_4 + space_2_3):</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>, rest_3_1[li[<span class="number">3</span>] % <span class="number">4</span>] + ((space_2_4 + space_2_3) - li[<span class="number">2</span>]) * <span class="number">4</span>]</span><br><span class="line">    <span class="keyword">elif</span> li[<span class="number">2</span>] - (space_2_4 + space_2_3) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> [-(-(li[<span class="number">2</span>] - (space_2_4 + space_2_3)) // <span class="number">9</span>),</span><br><span class="line">             <span class="number">4</span> * rest_more_2[(li[<span class="number">2</span>] - (space_2_4 + space_2_3)) % <span class="number">9</span>] + rest_3_1[li[<span class="number">3</span>] % <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">num_1</span>(<span class="params">li, a</span>):</span><br><span class="line">    rest = a[<span class="number">1</span>] + li[<span class="number">5</span>] * <span class="number">11</span></span><br><span class="line">    <span class="keyword">if</span> li[<span class="number">1</span>] - rest &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> li[<span class="number">1</span>] - rest &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -(-(li[<span class="number">1</span>] - rest) // <span class="number">36</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pack</span>(<span class="params">li</span>):</span><br><span class="line">    a = num_2(li)</span><br><span class="line">    <span class="keyword">return</span> li[<span class="number">6</span>] + li[<span class="number">5</span>] + li[<span class="number">4</span>] + (-(-li[<span class="number">3</span>] // <span class="number">4</span>)) + a[<span class="number">0</span>] + num_1(li, a)</span><br><span class="line"></span><br><span class="line">all_order = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    a, b, c, d, e, f = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">if</span> a == b == c == d == e == f == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        all_order.append([<span class="number">0</span>, a, b, c, d, e, f])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(all_order)):</span><br><span class="line">    <span class="built_in">print</span>(pack(all_order[i]))</span><br></pre></td></tr></table></figure>

<p>代码运行截图 &#x3D;&#x3D;（AC 代码截图，至少包含有”Accepted”）&#x3D;&#x3D;</p>
<p>![image-20230930184820898](&#x2F;Users&#x2F;liangzhong&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230930184820898.png)</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5></div><div class="article-licensing box"><div class="licensing-title"><p>Introduction to Computing B (yhf) Cheetsheet</p><p><a href="http://lzliangzh.github.io/2024/02/16/cheetsheet-for-cs101/">http://lzliangzh.github.io/2024/02/16/cheetsheet-for-cs101/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="http://lzliangzh.github.io"><p>o0o0o0o</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-02-16</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-05-10</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2024/01/06/cover/" target="_blank"> </a><br></span><span>  2.<a class="is-size-6" href="/2023/12/29/%E2%80%9C%E9%81%A9%E2%80%9D%E5%AF%A6%E8%A9%9E%E8%A9%9E%E7%BE%A9%E5%BC%95%E7%94%B3%E7%99%BC%E5%B1%95%E8%84%88%E7%B5%A1%E6%A2%B3%E7%90%86/" target="_blank">“適” 實詞詞義引申發展脈絡梳理</a><br></span></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/03/02/%E8%BF%91%E6%9C%9F%E6%8A%98%E8%85%BE%EF%BC%9A%E7%94%A8%E9%A6%99%E6%A9%99%E6%B4%BE%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">在香橙派上简易建站并远程访问 (Mkdocs based)</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/02/02/easyuse-terminal/"><span class="level-item">Easy-use Terminal</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://lzliangzh.github.io/2024/02/16/cheetsheet-for-cs101/';
            this.page.identifier = '2024/02/16/cheetsheet-for-cs101/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'DISCUS' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/./avatar.jpeg" alt="o0o0o0o"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">o0o0o0o</p><p class="is-size-6 is-block">北京大学</p><p class="is-size-6 is-flex justify-content-center"><span>Beijing, China &amp;&amp; Xiamen, Fujian, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="/about" target="_blank" rel="noopener">关注我</a></div><div><p id="hitokoto">With no fear in my heart, God comes into my mind.</p></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://blog.yixuan-wang.site" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Yixuan-Wang&#039;s site</span></span><span class="level-right"><span class="level-item tag">blog.yixuan-wang.site</span></span></a></li><li><a class="level is-mobile" href="https://arthals.ink" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Arthals</span></span><span class="level-right"><span class="level-item tag">arthals.ink</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Something-Interesting/"><span class="level-start"><span class="level-item">Something Interesting</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%AF%86%E5%8F%8B%E6%9D%A5%E7%A8%BF/"><span class="level-start"><span class="level-item">密友来稿</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/"><span class="level-start"><span class="level-item">生产力</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E9%9A%8F%E7%AC%94/"><span class="level-start"><span class="level-item">随笔</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-28T14:59:42.792Z">2024-04-28</time></p><p class="title"><a href="/2024/04/28/2024-may/">将五月</a></p><p class="categories"><a href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-25T16:00:00.000Z">2024-03-26</time></p><p class="title"><a href="/2024/03/26/%E6%9C%AC%E5%9C%B0%E8%A7%86%E9%A2%91%E6%80%BB%E7%BB%93%E6%8E%A2%E7%B4%A2/">本地视频总结探索</a></p><p class="categories"><a href="/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/">生产力</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/03/16/terminal-output-HZK16/"><img src="/gallery/terminal-output-HZK16/display0.png" alt="终端输出 HZK16(F) 点阵字"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-03-15T16:00:00.000Z">2024-03-16</time></p><p class="title"><a href="/2024/03/16/terminal-output-HZK16/">终端输出 HZK16(F) 点阵字</a></p><p class="categories"><a href="/categories/Something-Interesting/">Something Interesting</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-11T16:00:00.000Z">2024-03-12</time></p><p class="title"><a href="/2024/03/12/Retro%20Journey/">Retro Journey</a></p><p class="categories"><a href="/categories/Something-Interesting/">Something Interesting</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-01T16:00:00.000Z">2024-03-02</time></p><p class="title"><a href="/2024/03/02/%E8%BF%91%E6%9C%9F%E6%8A%98%E8%85%BE%EF%BC%9A%E7%94%A8%E9%A6%99%E6%A9%99%E6%B4%BE%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A8/">在香橙派上简易建站并远程访问 (Mkdocs based)</a></p><p class="categories"><a href="/categories/Something-Interesting/">Something Interesting</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2024/04/"><span class="level-start"><span class="level-item">四月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/02/"><span class="level-start"><span class="level-item">二月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/01/"><span class="level-start"><span class="level-item">一月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%80%E5%B9%B4%E5%8D%8A%E8%BD%BD/"><span class="tag">一年半载</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AD%E6%96%87%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E5%8F%B2/"><span class="tag">中文信息处理史</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%A4%E4%BB%A3%E6%BC%A2%E8%AA%9E/"><span class="tag">古代漢語</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/favicon.svg" alt="1ntersection" height="28"></a><p class="size-small"><span>&copy; 2024 o0o0o0o</span><br></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>