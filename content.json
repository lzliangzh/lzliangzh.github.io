{"posts":[{"title":"","text":"鼓浪嶼的碼頭 A pier on the shore of Kulangsu Welcome to my blog! / 欢迎来到我的小站阅读我的文章，你可以下滑浏览，可从「最新文章」进入，亦可单击时间线/分类/标签，按其逻辑浏览。 愿你有一个快乐的阅读体验！ To read my articles, you can scroll through them from “Latest Articles” or click Timeline/Categories/tags to follow their logic. May you have a happy reading experience!","link":"/2024/01/06/cover/"},{"title":"将五月","text":"马上就五一了。 今日有雨。 乍暖还寒时，清冷湿润间， 绿草春泥，莺歌燕舞，欢声笑语。 雨声绵绵，濯洗万物。 叶摇曳，绿更绿。 擦亮砖石，涤净窗棂。 雨沿阶下，经过蜗牛、青蛙， 流进下水潺潺，流进湖中，流进涟漪里。 打湿小衣裳，纷乱读书心， 点起行人蹁跹舞。 见他们奔东西。 小岛的雨。 云积锁流光，雨连梦漫长。 一隅钟暖意，再醒人彷徨。","link":"/2024/04/28/2024-may/"},{"title":"本地视频总结探索","text":"下午把数算课给旷了。为了更快地了解这次课上了什么，回想到B站视频总结和要点功能的实现，于是就想要实现 本地视频的总结。今天探索了一些方法，最终有一个方法是比较有效果的。 如何把教学网的视频下载到本地？由于教学网的视频显然没有现成的字幕可用，并且也没有现成的插件能够提取字幕+喂给GPT，因此只能采用比较笨的下载到本地的办法。 刷树洞发现 https://leohlee.github.io/pkuVideo.html 可以实现把教学网的视频下载到本地。为了防止网页被封，我下载了一份源代码到本地了。 教学网的 m3u8 是经过 AES 加密的，无法用网络上常见的 m3u8 下载器下载。尽管获取解密密钥并不难，但有违自动化的原则。 ~/N_m3u8DL-RE_Beta_osx-arm64 是本地的 m3u8 下载器，按网上说法支持 AES 解密，但是下载的文件不知道咋运行。 如何给本地的视频生成字幕？这里就有两种实现途径： 本地转换生成字幕，考虑到毕竟 Mac 的处理器还是有 MPS 神经网络加速的； 上传云端，让云端转换生成字幕。 本地生成本地生成，在本地放置模型文件，使用下列二者其一 Buzz(仅支持CPU，支持Mac)， brew install --cask buzz WhisperDesktop (GPU或CPU皆可，但不支持Mac)，https://github.com/Const-me/Whisper/tree/master 驱动模型生成字幕。 缺点： 理论上，只安装 Buzz 或者 WhisperDesktop，如果本地没有模型，也可以自动下载模型文件；奈何 https://huggingface.co/ 网络常常无法连接，因此只好在镜像站 https://hf-mirror.com/ggerganov/whisper.cpp/tree/main 下载，然后放到指定位置去（Buzz 在 .cache/whisper）里头。 而且由于本地算力不足，实际上转换一个 3 小时的课程视频需要跑 7 小时（甚至睡一觉起来都不一定能行） 上传云端、下载字幕+把字幕喂给 GPT（Gemini API 的使用方法）剪映、飞书等平台，以及 Memo AI 等新平台，都号称支持视频转文字，但只有飞书目前还是免费。由于需要把字幕喂给 GPT，并且 Github 上有 Feishu 的上传下载 Python 脚本，因此还是选择飞书作为云端转文字平台，同时通过修改脚本，把下载下来的文字文件喂给 GPT，通过合适的 Prompt 生成总结+要点，再写入本地 Markdown 文件。 原程序代码：https://github.com/bingsanyu/feishu_minutes 接入大模型——这里使用 Gemini 作为总结大模型。通过阅读 https://ai.google.dev/tutorials/quickstart?hl=zh-cn#python_1，Python 接入 Gemini API 的方法如下： 首先执行下面的步骤，运行 py 脚本 1pip3 install -q -U google-generativeai 123456789import google.generativeai as genaigenai.configure(api_key=os.environ[&quot;API_KEY&quot;]) # 如果这里报错，改成下面那行代码# genai.configure(api_key=&quot;&lt;your_API&gt;&quot;)model = genai.GenerativeModel('gemini-pro')response = model.generate_content(&quot;Write a story about a magic backpack.&quot;)print(response.text) 如果报一个有关认证的错误，需要「设置应用默认凭据」通过谷歌认证，方可使用 API。使用下面的代码： 通过运行 gcloud auth application-default login命令向 ADC 提供用户凭据。此命令会将包含您提供的凭据（通常来自您的 Google 账号）的 JSON 文件置于文件系统上的熟知位置。该位置取决于您的操作系统： Linux、macOS：$HOME/.config/gcloud/application_default_credentials.json Windows：%APPDATA%\\gcloud\\application_default_credentials.json 12credential_path = &quot;/Users/liangzhong/.config/gcloud/application_default_credentials.json&quot; # os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = credential_path 这部分参考： https://cloud.google.com/docs/authentication?hl=zh-cn#developer_workflow https://cloud.google.com/docs/authentication/application-default-credentials?hl=zh-cn#personal https://cloud.google.com/sdk/docs/install?hl=zh-cn#mac","link":"/2024/03/26/%E6%9C%AC%E5%9C%B0%E8%A7%86%E9%A2%91%E6%80%BB%E7%BB%93%E6%8E%A2%E7%B4%A2/"},{"title":"终端输出 HZK16(F) 点阵字","text":"HZK16 点阵字是诸多点阵电显使用的字库文件。小时候常常乘坐的 36 路公交车，使用的应该就是这个字库，因为 HZK16 的全角感叹号很有特色（目前已经比较少见到了）。一些普速列车上的电显似乎也是用此字体。为表怀念，便尝试实现输出一下。 需要准备 HZK16 或 HZK16F 点阵字文件；此外，要新建 display.txt 文件，在里面填写打印的字符内容。 可以用 ASCII 实现好多有意思的事情，比如： 12345678910111213141516171819202122 ┌─────────┐ │厦门火车站欢迎您！│ └─────────┘ 到 达 列 车 信 息 车 次 始 发 终 到 开 点 检票口 站 台 状 态Ｋ４６ 福 州 北 京 ０８∶５８ ７ １ 正 点Ｄ６３３３ 厦 门 福 鼎 ０９∶０３ ５ ２ 正 点Ｄ１ 哈尔滨 北京南 １０∶１０ ４ ３ 晚点１分Ｚ３４６ 厦 门 贵 阳 １１∶１７ ２ ５ 正 点Ｄ３２１７ 上海虹桥 深圳北 １５∶０８ ３ ２ 正 点Ｄ４０１０ 汉 口 厦 门 １５∶２１ ５ ４ 晚点２时１０３３ 厦 门 福 州 １５∶５０ ４ １ 正 点Ｌ５４３２ 厦 门 建 瓯 １６∶０１ ６ ３ 正 点━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━９７年０３月１５日。 天气：中到大雨。 ００∶１１∶０１旅客们，接市气象台通知，受强台风“杜苏芮”影响，即时起，途径厦门站的所有车次列车停运。给您造成的不便敬请谅解！恢复时间另行通知。华夏电子有限公司高端电子显示屏 Ｒ 合作电话：０５９２－２０３９４８９ 12345678910111213141516171819202122232425262728293031323334353637383940414243新１２年０３月１６日星期六（２０∶００）──────警告！警告！警告！──────侦测到实体闯入安全规则特别区。立即启动措施？１）是 ２）否正在清除实体……清除失败。安全规则特别区存在危险，启动自毁程序。新１２年０３月１６日星期六（２０∶１２）─────────通☆知─────────安全规则已更新。接上级通知，即时起，封锁安全规则特别区，清除区域内诸实体。普遍安全规则区守戒级别更订为严重紧张。已请求１０基地增援。新１２年０３月１６日星期六（２０∶１４）─────────命☆令─────────第００１号命令：◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇讯息接收失败。警告：中央情报室可能正在遭受攻击。征０１年０３月１６日星期六（２０∶２１）─────────命☆令─────────第００２号命令：（远程发布，非公开）全体人员迅速撤离！１０基地已全面接管中央情报室。中央情报室征０１年０３月１６日星期六（２０∶２２）─────────命☆令─────────第００３号命令：决定清除电显终端本地历史记录。征０１年０３月１６日星期六（２０∶２２）─────────命☆令─────────第００４号命令：决定执行管制。征０１年０３月１６日星期六（２０∶２２）─────────命☆令─────────第００５号命令：（远程发布，非公开）我室结束使命。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import binasciiimport osimport timeKEYS = [0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01]def printPlay(textStr,line,background): # 初始化16*16的点阵位置，每个汉字需要16*16=256个点来表示，需要32个字节才能显示一个汉字 # 之所以32字节：256个点每个点是0或1，那么总共就是2的256次方，一个字节是2的8次方 rect_list = [] * 16 for i in range(16): rect_list.append([] * 16) for text in textStr: #获取中文的gb2312编码，一个汉字是由2个字节编码组成 gb2312 = text.encode('gb2312') #将二进制编码数据转化为十六进制数据 hex_str = binascii.b2a_hex(gb2312) #将数据按unicode转化为字符串 result = str(hex_str, encoding='utf-8') #前两位对应汉字的第一个字节：区码，每一区记录94个字符 area = eval('0x' + result[:2]) - 0xA0 #后两位对应汉字的第二个字节：位码，是汉字在其区的位置 index = eval('0x' + result[2:]) - 0xA0 #汉字在HZK16中的绝对偏移位置，最后乘32是因为字库中的每个汉字字模都需要32字节 offset = (94 * (area-1) + (index-1)) * 32 font_rect = None #读取HZK16汉字库文件 with open(&quot;HZK16&quot;, &quot;rb&quot;) as f: #找到目标汉字的偏移位置 f.seek(offset) #从该字模数据中读取32字节数据 font_rect = f.read(32) #font_rect的长度是32，此处相当于for k in range(16) for k in range(len(font_rect) // 2): #每行数据 row_list = rect_list[k] for j in range(2): for i in range(8): asc = font_rect[k * 2 + j] #此处&amp;为Python中的按位与运算符 flag = asc &amp; KEYS[i] #数据规则获取字模中数据添加到16行每行中16个位置处每个位置 row_list.append(flag) #根据获取到的16*16点阵信息，打印到控制台 for row in rect_list: for i in row: if i: #前景字符（即用来表示汉字笔画的输出字符） print(line, end=' ') else: # 背景字符（即用来表示背景的输出字符） print(background, end=' ') print()#----------------------------以上是库的引用和函数定义，下面是代码正文----------------------#允许用户自定义输入汉字短语os.system('clear')with open('display.txt', 'r') as file: li = [] for f in file.readlines(): f = f.rstrip('\\n') if f == &quot;&quot;: time.sleep(5) li.append(f) # print(li) #自定义点阵字中笔画的符号 lineSign = '●' #备选方案 #lineSign = &quot;0&quot; #自定义点阵字的背景符号 backgroundSign = ' ' #备选方案 #backgroundSign = &quot;.&quot; #调用之前定义好的函数，打印最终成果 printPlay(f,lineSign,backgroundSign) time.sleep(0.01)","link":"/2024/03/16/terminal-output-HZK16/"},{"title":"Retro Journey","text":"笔者周一下午在 LCPU 群中得知 Windows on Docker 已被开发出来后，对跨平台的力量有了更深刻的认识。在对 Windows 发展史的深入探究（指刷 Wikipedia）中，我在无意间看到了「倚天中文系统」这个概念，一股早期中文信息处理的怀旧风味涌上心头，使我迫不及待地想重温一下，那个年代人们文字处理的趣味。于是便开始折腾了。 「中文系统」特指 Base on DOS 的中文界面，结合最原始的 OpenGL 输出，显示出的点阵字正是中国信息化起步年代的标识。由于手头上只有 Apple Silicon 的设备，因此，在 Apple Silicon 上安装并汉化 DOS 就成为不可避免的问题。 中文系统举隅因为很多系统的文件有缺失、受损，或完整但会卡死（猜测受限于架构问题），所以对大多数中文系统的体验，只是浅尝辄止。我粗略地体验了如下几个中文系统： 天汇中文系统（TWAY/TW31）：北京大学朱守涛教授主持设计，简中版本，精简版（仅中文系统+输入法）可以使用，完整版有文件缺失/执行问题。 倚天中文系统（ET350/ETHEN_CN）：台湾开发，在台湾较为流行，有简中和繁中版本，但在 DOSBOX 运行会乱码。 汉鼎中文系统（HAN32）：有文件缺失（？）。 希望中文系统（UCDOS）：北京希望公司研制的汉字系统，简中版本，目前测试的结果是： 在 DOSBOX 下，安装有时会提示插入其他盘而终止（Win on ARM 始终找不到解决方案，Mac on Apple Silicon 要运行文件夹 1 下的那个 install.exe 并且选择客制化安装）； 运行，可以使用图形界面（UCSHELL）、Super-WPS 等几乎所有软件；但是 PRNT 无法识别驱动程式，列印相关的程式均完全无法运行。 在 DOS 虚拟机（Base UTM，DOS 7.10）上可以顺利安装运行。注意 UTM 虚拟机的配置：CPU 要选择 i386 架构，型号选择 486；机型要选择 ISA-only PC(isapc)。否则，安装完后，从硬盘启动时，会卡在 LOGO 界面。 CCDOS：暂未使用。","link":"/2024/03/12/Retro%20Journey/"},{"title":"在香橙派上简易建站并远程访问 (Mkdocs based)","text":"2024/2/29～2024/3/2，周四到周日（其实次周周二还在折腾）。拿香橙派搭好云盘后，想着干脆把 1ntersection 网站也部署到上面好了，毕竟自己的东西用的还是放心，放一些私人的东西也安全。 有关静态网页生成器的选择 Mkdocs 支持 serve 到指定 ip，也支持 ipv6 地址，比较简单，不过只能 serve 到一个 ip，即本机的 ipv4 和 ipv6 不能同时 serve。 其他的静态网页生成器（例如 Gitbook, Vuepress）只能生成 html 网页，需要用 nginx/apache2 serve 到 ip（注意：将根目录指向 html 网页所在处）。 在配置 nginx/apache2 的时候，尽量注意备份😭 有一个插件 mkdocs-callouts 可以实现以比较易用的代码格式编写 admonition，就像这样： 123&gt; [INFO|left] Title&gt; &gt; Some pieces of information 效果如下。 [!INFO|left] Title Some pieces of information 有关 Mkdocs 更换主题mkdocs-material 主题确实赏心悦目，但看久了有点腻，而且上面的大 title-bar 给人压的喘不过气。Gitbook 或者 Mkdocs 自带的几个主题虽然简单但耐看。 因此萌生了更换主题的想法。更换主题最主要的难点就是 Material 主题所支持的众多插件其他主题并不支持。目前比较要紧的如下。 功能 插件 测试支持情况 代码高亮（代码相关） Readthedocs 支持，Gitbook 不支持 告诫框 Readthedocs 有部分设计样式（仅非伸缩告诫框有），Gitbook 未设计样式（一点儿也没有），必须使用 Gitbook 的话得自己写 extra.css，具体见本站 extra.css 搜索 均不支持 对于 Gitbook 的调试有这样的现象：gitbook 主题的 css 要求 html, body, .book-body 三者 height: 100%; 才能将右侧内容显示完全，否则显示不完全甚至几乎消失。但是设置 height: 100%; 以后，打印网页只能打印 1 页纸。这令人非常揪心。 上网搜索了解到，解决方法是将 html, body 的height设为auto。然而这并没有结束，此时页面就出现了内容消失的情况。进一步解决方案是：调整 body 子元素的 position 为 relative/absolute/fixed（视情况而定）。 还未解决的问题 告诫框「!!!」引导的样式尚未完成自定义 css 编写。","link":"/2024/03/02/%E8%BF%91%E6%9C%9F%E6%8A%98%E8%85%BE%EF%BC%9A%E7%94%A8%E9%A6%99%E6%A9%99%E6%B4%BE%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"Introduction to Computing B (yhf) Cheetsheet","text":"计算概论 B （实验班） 机考材料 考试地点：机房 6B 座位 71 http://cs101.openjudge.cn 提醒 读题：抄录关键字。写程序前要画出流程图，如标清楚空位从何而来，以防重复或遗漏 debug：（1）把题目一字不落地读 2-3 遍，再看看你的程序；（2）对照测试数据（边界数据）时，走程序流程，笔脑结合，更清晰准确。 时间复杂度：简单题别想复杂。 输入数据 $10^4$，$O(n^2)$ 差不多可以 AC。 如果$10^5$以上，需要考虑 $O(n\\log n)$ 方法。 $10^2$ ，可以多重循环，但要注意遍历的顺序。要求按字典序排，则必须从前位往后位遍历。后位的range参数当然可以与前位依赖！range(b, a) OJ02810: 完美立方 math：Python 支持大整数运算（这点比 C 好太多了），但是注意数很大的时候运算可能会很慢，所以应当用提前取模的办法尽量避免超大数的运算（OJ02706 麦森数）。 有除法的时候如果确保整除，用//代替/（OJ18155 组合乘积）。除法还要注意是否可能出现除以 0 的情况（OJ18223 24 点） 还要再注意：取模 $x % n\\in[1,n)$、整除 $x//n=a…r$ 是向下取整 舍入时注意 round 不是严格意义上的四舍五入，遇到恰好.5 会向偶数舍入。floor 和 ceil 是安全的（当然如果刚好是整数也可能会有精度方面的问题） float 的等于判断不能用“==”，return abs(f1 - f2) &lt;= allowed_error 。例如：OJ12065 方程求解，可以 allowed_error = 1e-12 列表：反复 remove 很有可能导致超时，这里的办法一般是==开一个真值表先打标记（参见“懒删除”）== 遍历列表的时候通常用 for 循环；但是尽量避免一边循环一边删除/添加元素。如果必须的话建议改用 while 循环。 匿名函数 lambda x,y:f(x,y) 有时候比单独定义一个函数方便得多（尤其在作为 key 参数的时候） 数据预处理：预处理是“打表”的一种最简单也最常用的方式，预先记录某些信息以便处理问题时直接调用，避免重复计算。常见方法如记录“前缀和”以快速得到任意连续段的和（这种方法还可推广到高维的前缀和），利用差分数组以方便对连续段的同时更新（一段同时加 x 反映在差分数组上就是头加 x,尾减 x;再用前缀和还原即可），打下标和值的对应表以方便查找值在列表中的位置，打真值表以方便查找值是否出现过（用集合也可以，但效率稍差），打计数桶以方便查找值出现的次数等。 维护适当的信息：这里所说的信息和预处理中的不同，它们在任务执行过程中可能改变。如果维护太多的信息，在更新信息时可能很麻烦；如果维护太少的信息，求解问题时又可能需要复杂的运算。寻找合适的信息来维护，既便于更新，又便于求解（或者说分摊更新与求解的复杂度），常常是这类问题的关键。 通常会考虑维护一些特征量，例如最大值、最小值、端点/边界点、某个特征值出现次数、某个极端位置的量等；这些特征量足够提供求解问题的信息，而又不像全状态那样难以维护。 （这样的题目很多，在很多算法中其实也都有这样的思想；例子暂时想不起来了，大家可以自行补充） 数据的输入与输出列表常见输入输出。矩阵的输入输出，见“矩阵”模块 12345678910111213# 列表的输入——从空格分隔变成列表（妙招）*value, = map(int, input().split())# 矩阵的输出——从嵌套列表 变成空格分割print( *(' '.join(map(str, row)) for row in mx), sep='\\n')for i in range(1, n+1): # 法2 print(' '.join(map(str, mx[i][1:-1])))# 未明确输入组数时，需要套壳while True: try: # except EOFError: break 深拷贝列表：使用列表推导式！或者 deepcopy 12li = [1,2,3,4,5]li2 = [item for item in li] 整数保留最后$n=9$位，小数保留前$n=9$位： 12a[i]=(a[i-1]+a[i/2])%1000000000;*//取余是为了只输出最后9位*print('%.9f' % num) 1234567891011121314151617181920for index,value in enumerate(list)list(zip(a,b))&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b) # 返回一个对象&gt;&gt;&gt; zipped&lt;zip object at 0x103abc288&gt;&gt;&gt;&gt; list(zipped) # list() 转换为列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; list(zip(a,c)) #== 元素个数与最短的列表一致 ==!!!!!!!![(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; a1, a2 = zip(*zip(a,b)) # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式&gt;&gt;&gt; list(a1)[1, 2, 3]&gt;&gt;&gt; list(a2)[4, 5, 6]&gt;&gt;&gt; 基本数据结构的语法技巧字符串直接进行&gt;&lt;=比较：按照字典序 数、字符虚数：complex(real,imagine)或complex(&quot;1+2j&quot;)(不能带空格) str()处理列表等元素序列, 不会删去括号和&quot;&quot;; 而repr() 方法可以将读取到的格式字符，比如换行符、制表符，转化为其相应的转义字符。 eval()函数，执行括号内的字符串 tuple(),set(),list()用法相似, list([str])可以拆分字母; 还有frozenset() dict() 的使用方法如下 123456&gt;&gt;&gt; dict(a='a', b='b', t='t') # 传入关键字{'a': 'a', 'b': 'b', 't': 't'}&gt;&gt;&gt; dict(zip(['one', 'two', 'three'], [1, 2, 3])) # 映射函数方式来构造字典{'three': 3, 'two': 2, 'one': 1}&gt;&gt;&gt; dict([('one', 1), ('two', 2), ('three', 3)]) # 可迭代对象方式来构造字典{'three': 3, 'two': 2, 'one': 1} ord() 把字符转换成 ASCII 码，在处理字典序问题时常用。 chr() 把 ASCII 码转换成字符。gap = ord('a') - ord('A') hex() 16 进制数，oct() 8 进制数，bin()二进制 12345678910111213s = input()gap = ord('a') - ord('A')ans = []for i in s: if 'A' &lt;= i &lt;= 'Z': ans += chr(ord(i) + gap) elif 'a' &lt;= i &lt;= 'z': ans += chr(ord(i) - gap) else: ans += iprint(''.join(ans)) 字符串str.lstrip() / str.rstrip()移除字符串左侧/右侧的空白字符。 str.find(sub): 返回子字符串sub在字符串中首次出现的索引，如果未找到，则返回-1。 str.replace(old, new): 将字符串中的old子字符串替换为new。 str.startswith(prefix) / str.endswith(suffix): 检查字符串是否以prefix开头或以suffix结尾。 str.isalpha() / str.isdigit() / str.isalnum(): 检查字符串是否全部由字母/数字/字母和数字组成。 str.title()首字母大写（每个单词），str.lower()/upper(）每个字母小/大写，str.zfill()自动在前面补 0 补到所需位数 其他 int(str,n) for key,value in dict.items() dict.get(key,default) math.pow(m,n) math.log(m,n) lrucache 工具正则表达式语法、ASCII 码 正则表达式语法ASCII 表 推荐数据结构、常用库试试使用桶排序（分区间，分治）、堆、优先队列 quene ||||||| 字典、集合、stack 集合打表能过 。set, frozenset (=保证元素唯一性的 tuple) ——set/dict 插入都是 O(1)。例外：用 set/dict 处理保证元素唯一性问题。368B. Sereja and Suffixes本来使用集合处理“不同元素”的条件，发现集合的 add 方法有最坏时间复杂度$O(n)$；后用字典依然 TLE 于 test11，询问 GPT 得知：当向字典中添加键值对时，如果该键值对的哈希值与字典中的其他键值对发生冲突，将会触发重新哈希和重新分配内存的操作。这种情况下，添加键值对的效率可能会降低，并**导致最坏情况下的时间复杂度$O(n)$**。 ① 如何去重效率最高？最后再去重！② 实在过不了——使用 DP 思想解题。 from itertools import permutation from collections import defaltdict：更省事，不用判断 key 有无 123456789101112131415161718192021222324252627import heapqli = []heap = []item = 0heapq.heappush(heap, item) # 向堆中插入元素, 并梳理成堆heapq.heappop(heap) # 从堆中弹出 最小元素heapq.heapify(li) # 梳理成堆heapq.heapreplace()'''Pop and return the current smallest value, and add the new item. This is more efficient than heappop() followed by heappush(), and can be more appropriate when using a fixed-size heap. **Note that the value returned may be larger than item!** That constrains reasonable uses of this routine unless written as part of a conditional replacement: if item &gt; heap[0]: item = heapreplace(heap, item)'''heapq.nlargest(n, li) # 弹出列表中最大的 n 个元素heapq.nsmallest(n, li) # 同理heapq.heappushpop(heap, item) # Fast version of a heappush followed by a heappop.数据全反号——大根堆a, b, c, d = [1, 2, 3, 4] # 技巧插入、弹出：O(logn)，O(logn)，同时稳定维持了堆结构（最大值、最小值） math12345678import mathprint(math.ceil(1.5)) # 2print(math.pow(2,3)) # 8.0print(math.pow(2,2.5)) # 5.656854249492381print(9999999&gt;math.inf) # Falseprint(math.sqrt(4)) # 2.0print(math.log(100,10)) # 2.0 math.log(x,base) 以base为底，x的对数#阶乘factorial,组合数comb lru_cache@lru_cache(maxsize=None)。使用@lru_cache 装饰器时，应注意以下几点：① 被缓存的函数的参数必须是可哈希的，这意味着参数中不能包含可变数据类型，如列表或字典。② 缓存的大小会影响性能，需要根据实际情况来确定合适的大小或者使用默认值。③ 由于缓存中存储了计算结果，可能导致内存占用过大，需谨慎使用。④ 可以是多参数的。 bisect（二分查找）123456789101112import bisectsorted_list = [1,3,5,7,9] #[(0)1, (1)3, (2)5, (3)7, (4)9]position = bisect.bisect_left(sorted_list, 6)print(position) # 输出：3，因为6应该插入到位置3，才能保持列表的升序顺序bisect.insort_left(sorted_list, 6)print(sorted_list) # 输出：[1, 3, 5, 6, 7, 9]，6被插入到适当的位置以保持升序顺序sorted_list=(1,3,5,7,7,7,9)print(bisect.bisect_left(sorted_list,7))print(bisect.bisect_right(sorted_list,7))# 输出：3 6 年份 calendar 包1234567891. `calendar.month(年, 月)`: 返回一个月份的日历字符串。它接受年份和月份作为参数，并以多行字符串的形式返回该月份的日历。2. `calendar.calendar(年)`: 返回一个年份的日历字符串。这个函数生成整个年份的日历，格式化为多行字符串。3. `calendar.monthrange(年, 月)`: 返回两个整数，第一个是该月第一天是周几（0-6表示周一到周日），第二个是该月的天数。4. `calendar.weekday(年, 月, 日)`: 返回给定日期是星期几。0-6的返回值分别代表星期一到星期日。5. `calendar.isleap(年)`: 返回一个布尔值，指示指定的年份是否是闰年。6. `calendar.leapdays(年1, 年2)`: 返回在指定范围内的闰年数量，不包括第二个年份。7. `calendar.monthcalendar(年, 月)`: 返回一个整数矩阵，表示指定月份的日历。每个子列表表示一个星期；天数为0表示该月份此天不在该星期内。8. `calendar.setfirstweekday(星期)`: 设置日历每周的起始日。默认情况下，第一天是星期一，但可以通过这个函数更改。9. `calendar.firstweekday()`: 返回当前设置的每周起始日。 Counter 包、Permutations 包123456789101112from collections import Counter # O(n)# 创建一个待统计的列表data = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']# 使用Counter统计元素出现次数counter_result = Counter(data) # 返回一个字典类型的东西# 输出统计结果print(counter_result) # Counter({'apple': 3, 'banana': 2, 'orange': 1})print(counter_result[&quot;apple&quot;]) # 3from itertools import permutations as perelements = [1, 2, 3]permutations = list(per(elements)) default_dictdefaultdict 是 Python 中 collections 模块中的一种数据结构，它是一种特殊的字典，可以为字典的值提供默认值。当你使用一个不存在的键访问字典时，defaultdict 会自动为该键创建一个默认值，而不会引发 KeyError 异常。 defaultdict 的优势在于它能够简化代码逻辑，特别是在处理字典中的值为可迭代对象的情况下。通过设置一个默认的数据类型，它使得我们不需要在访问字典中不存在的键时手动创建默认值，从而减少了代码的复杂性。 使用 defaultdict 时，首先需要导入 collections 模块，然后通过指定一个默认工厂函数来创建一个 defaultdict 对象。一般来说，这个工厂函数可以是 int、list、set 等 Python 的内置数据类型或者自定义函数。 12345678from collections import defaultdict# 创建一个defaultdict，值的默认工厂函数为int(也可以是list -&gt; [0])，表示默认值为0char_count = defaultdict(int)# 统计字符出现次数input_string = &quot;hello&quot;for char in input_string: char_count[char] += 1print(char_count) # 输出 defaultdict(&lt;class 'int'&gt;, {'h': 1, 'e': 1, 'l': 2, 'o': 1}) 其他1234567891011121314151617# 累积import functoolsnumbers = [1, 2, 3, 4, 5]# 使用 reduce 计算累积乘积product = functools.reduce(lambda x, y: x * y, numbers)# ——————————————————————————————————————————————# 笛卡尔积from itertools import product# 创建两个可迭代对象colors = ['red', 'blue']numbers = [1, 2]# 生成它们的笛卡尔积cartesian_product = list(product(colors, numbers))# 创建一个可迭代对象colors = ['red', 'blue']# 生成它们的重复笛卡尔积repeat_cartesian_product = list(product(colors, repeat=3)) 矩阵1）横纵坐标看清楚了！==“横 x 纵 y”==还是==“行 x 列 y”==，完全不一样！2）矩阵的字典序比较； 12345# 3）输入。是否split看题意！——————①加保护圈输入ipt = [['']+list(input())+[''] for _ in range(h)]board = [['']*len(ipt[0])]+ipt+[['']*len(ipt[0])]#——————②不加保护圈输入board = [list(input()) for _ in range(h)] 4）防止遍历矩阵越界的处理方式 ①对于“仅扫描邻居（最多越界一位）”的题目：可以考虑加全 0 或全-1 保护圈（508A. Pasha and Pixels,12560: 生存游戏）； ②对于“任意扫描半径”的题目：边界检查：for 循环中，range 使用 min/max 避免越界(02659:Bomb Game )。感觉到矩阵题目的序号问题犯错频率减少了。 5）矩阵旋转题（Perfect Square）技巧总结 ① 用 ord('a')转换为 ASCII ② 旋转 90° 均相等 $\\Leftrightarrow$ 中心+轴对称 ③ 题解中用 ~j=-j-1 ，~ 为按位取反，用于此题表示对称的索引值，是妙用。 【OJ18106: 螺旋矩阵】 对于无固定步长、有边界限制的操作，可以通过构造边界（如[-1]），并在操作中添加边界识别步骤，实现“撞南墙则回头”。 有向操作如果有周期，可新建变量d 、方向列表dirct = []，并用d%4(n)表示方位； 有向操作对前景的感知，需要在换向后进行； 12345678910111213141516171819202122232425262728293031def fill(n, mx): v = 1 dirct = [(1, 0), (0, 1), (-1, 0), (0, -1)] d = 0 r, c = 1, 1 fwd = 0 n = n*n while n &gt; 0: while fwd == 0: mx[r][c] = v n -= 1 fwd = mx[r+dirct[d%4][1]][c+dirct[d%4][0]] v += 1 if fwd == 0: pass else: d += 1 fwd = mx[r + dirct[d % 4][1]][c + dirct[d % 4][0]] c += dirct[d % 4][0] r += dirct[d % 4][1] return mxn = int(input())mx = [[-1]*(n+2)]for _ in range(n): mx.append([-1]+[0]*n+[-1])mx.append([-1]*(n+2))mx = fill(n, mx)for i in range(1, n+1): print(' '.join(map(str, mx[i][1:-1]))) 【OJ04133: 垃圾炸弹】 在某垃圾周围多大范围内，只要投掷炸弹必能炸掉此垃圾？将此范围内的值 +1 ，表示在此处投放炸弹能炸掉 1 个垃圾（即“此垃圾”） 相似地，考虑其他垃圾。如果某处值为 2，则表示在此处投放炸弹能炸掉 2 个垃圾 遍历整个城市，找到最大值，以及最大值出现了几次。 逆向思考，从垃圾思考，而不是从炸弹思考。 动态规划 dp递推计数这类问题严格来说不算 DP，就是用递推方法解决问题。最简单的譬如斐波那契型数列（OJ02786 Pell 数列，OJ23556 小青蛙跳荷叶），分拆数（OJ04119 复杂的整数划分问题）以及某些不定方程的解数之类的。 稍微难一点的例子譬如 OJ09267 核电站（不太容易建立递推），OJ04150 上机（首先要分析出题目需要满足的条件，转化为一个纯数列问题；其次需要按末位分类进行递推），OJ25573 红蓝玫瑰（需要加上一个数列，记录翻转过的序列所需的操作次数） 这类问题关键往往在于建立递推关系。无法直接建立递推关系时可以考虑引入若干辅助问题一并考虑：如果 A 问题能转移到 A 的同构问题和 B 的同构问题之一，而 B 问题也是如此，则同样可以递推解决。 一维 dp模型 1：【最大连续子列和】每一状态两种想法——① 继承，② 重做。选择 max 即可。返回dp[-1] 模型 2：【最长上升子列】每一状态两种想法——① 放入序列（继承前面最大可接项），② 不放入序列，继承前一项。选择 max 即可。返回max(dp) 还有一个 nlogn 的算法，非常巧妙（我自己肯定想不到）。维护数组 d,d[i-1]表示长为 i 的递增子序列中末位最小值。可以非常巧妙地维护 dp 数组，需要应用二分查找工具。 12345678910import bisectd = [A[0]]ans = 1for i in range(1,n): if A[i]&gt;d[-1]: d.append(A[i]) ans += 1 else: index = bisect.bisect_left(d,A[i]) d[index] = A[i] 模型 2 变式 1：【最大上升子序列和】把 dp 代表什么换了就行 模型 2 变式 2：【02711 合唱队列】每一状态两种想法——① 放入序列（继承前面最大**==可接项（如何判断是否可接）==**），② 不放入序列，继承前一项。返回max(dp) 模型 2 变式 3：【1195C Basketball Exercise】对于每一个相同编号的球员——① 选上面的/选下面的，③ 都不选（第一个编号是三种情况） 二维 dp模型 3：【最长公共子列】每一状态两种想法 ① 如果是公共的，这个状态的前一状态是两个子列都还没看到这个公共元素的时候，所以是dp[i-1][j-1]+1； ② 如果不是公共的，这个状态的前一状态是两个子列 还没看到这个元素的时候 上面的 dp 分别表示什么？ 注：最长回文子序列问题可化归为最长公共子序列问题：可以证明，A 的最长回文子序列长度等于 A 与 reversed(A)的最长公共子序列长度（并不显然）。例如 OJ01159 Palindrome 就可如此解决。 模型 4：数塔 dp ① 计算从根节点到第 $i$ 层每一个节点的最大和，并以之替代该节点。 ② 已知根节点到第 $i$ 层每一个节点的最大和，又已知第 $i+1$ 层各节点的值，可据此算出第 $i+1$ 层各节点的最大和。 背包 dp0-1 背包（原子性，课程学习 etc.）==偷商品的一部分（不具有原子性），使用贪心算法== 有 $n$ 件物品，每件物品的重量为 $w[i],$ 价值为 $c[i]$。现有一个容量为 $V$ 的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。 其中每件物品有且仅有 1 件. 考虑取前 i 个物品用 t 时间所能得到的最大值，枚举第 i 个物品是否取—— A）对于每一种时间情况下，能不能采某一种药，取决于： 总时间t是否大于 该药采集所耗时md[i][0] 如果时间不允许，则继承上一种药，dp[i-1][t] B）对于每一种时间情况下，要不要采某一种药，取决于： 不采，即该情况下，总价值为 dp[i-1][t] 采，即该情况下，总价值为dp[i-1][t-md[i][0]]+md[i][1] 何者更大。==注意一定要用 (i+1) * (t+1) 的 dp 表！把 0 算进去== ——来完成转移。注意这里加上时间参数 t，因为转移过程中 t 的限定可能会变。“加参数”是 DP 问题中最重要的技巧之一。 12345dp = [0]*Tfor i in range(n): for t in range(T,time[i]-1,-1): # 这里是 T+1！！！！ dp[t] = max(dp[t],dp[t-time[i]]+value[i])ans = dp[T] 这里采用“滚动数组”的方法将二维数组压缩成一维，是 DP 问题中常用的技巧。这基于选前 i 个物品的状态仅依赖于选前 i-1 个物品的状态。注意内层循环要倒着遍历！ 输出最佳方案——如果需要得到最佳方案，使用二维数组，使用回溯。 (注意: 若使用滚动数组，不能直接利用回溯求解方案) **==初始化技巧==**——初始化的 F 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为 -∞ 。 如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为 0，所以初始时状态的值也就全部为 0 了。这个小技巧完全可以推广到其它类型的背包问题。 完全背包将 0-1 背包中内层循环改为正着遍历即可（这里其实就利用了先前已经得到的信息来简化转移：在先前的转移中物品 i 可能已经用过若干次了） 多重背包 有 $n$ 件物品，每件物品的重量为$w[i],$ 价值为$c[i]$。现有一个容量为 $V$ 的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。 其中每件物品有$s[j]$件.（==和 0-1 背包的本质区别==） 最简单的思路是将多个同样的物品看成多个不同的物品，从而化为 0-1 背包。 前情提要：二进制优化——用二进制的各位【1, ~2, ~4, ~8, ~16, ~32, ~64, ~128 …】作**==桶==**，需要时按需凑即可。 ——编号最大（如 ~512）这个桶，可能装不满，比如说，装了 100 个。那么，当我需要凑一个大于 100 的数时，优先用这个桶，剩下再用其他桶找零。 二进制优化算法： 12345678910dp = [0]*Tfor i in range(n): all_num = nums[i] k = 1 while all_num&gt;0: use_num = min(k,all_num) #处理最后剩不足2的幂的情形 for t in range(T,use_num*time[i]-1,-1): dp[t] = max(dp[t-use_num*time[i]]+use_num*value[i],dp[t]) k *= 2 all_num -= use_nume 变式如果需要求出所有可能达到的值，需要用集合更新，状态设计方式不变（OJ01742 coins） 有时候可能需要考虑在给定所选物品的数量的情况下最优化，这时 dp 数组要多带一个数量参数（忘记哪个题了） 有时候背包问题的限制可能更多，需要加更多的参数（OJ04102 宠物小精灵之收服；这个题还有一个要点是更换参数的选取。设计 DP 状态时不一定把要求的作为最终结果，有时把要求的东西作为参数会更方便） 注：背包问题的 DP 解法需要时间 T 不太大，因为要遍历每个可能的 T。如果 T 很大而物品数量很少，采用 DFS 枚举物品的选法有时是更好的选择。 采用合适的顺序遍历某些问题看起来不方便用 DP 解决，因为状态似乎是无序的；但是只要能够找到状态的某个特征量有序，就可以以此为顺序完成 DP（当然这类问题最省脑子的办法参见“记忆化搜索”） OJ01088 滑雪：要求最长的递降通路长度，状态转移是容易的，但是顺序并不易确定。注意到每步总是往更低的地方滑，按高度从小到大遍历即可。 OJ01191 棋盘分割：每次分割后棋盘会变小，按棋盘的大小从小到大遍历即可（当然这样的话状态比较复杂；这题其实更适合记忆化搜索） OJ01661 帮助 Jimmy：每次会往下跳，按高度从下往上遍历即可；为了减少状态数，可以只考虑横坐标为某个平台端点的点（DP 相比记忆化搜索最大的缺陷就在于要设计出能够遍历的状态，而且要尽量减少状态数量） 目前就只能想到这么多了。。。。。。DP 无处不在，肯定还有很多技巧方法没有写到，啥时候想起来再补吧。 dp 技巧【CF189A: Cut Ribbon】 恰好切分：题目需要 Ribbon 被恰好地切分，因此状态转移方程只能为 1dp[i] = max(dp[i-a], dp[i-b], dp[i-c]) + 1 而不能为 1dp[i] = max(1+dp[i-a], 2+dp[i-b], 3+dp[i-c], dp[i-1]) 后者意味着：长度 i 的 Ribbon 继承 长度 i-1 的 Ribbon 的切法，即有边角料。 注意 Python 中负数列表索引不报错，被认为是列表末尾。 初始化：以 $-\\infty$ 初始化列表非首项，是为了保证： 特别地，在 Ribbon 达到可被切分的最小长度前，Ribbon 的切分不会被考虑； 对于某一特定长度，如果不存在一种切法，使得 Ribbon 被恰好地切分，那么该长度的 Ribbon 永远不会成为某一 Ribbon 的子 Ribbon，参与切分方法的考虑。 特别地，-inf在 Python 中表示 $-\\infty$ 。 深搜 DFS==枚举==所有完整路径，以遍历所有情况。不适合解决【障碍物少、空位多 → 路径可能性极多】的情况。 递归深度调整——sys.setrecursionlimit(1 &lt;&lt; 30) 步骤： 从起点开始走； 遇到==分岔路==进行标记，for i in range(n)，沿着第i个分岔路继续前进；（分岔？例如 if...else..., max[A, B], min[C, D]。有分叉都能深搜。） 遇到死路【==递归边界==】则return上一个分岔路口（==回溯==），i--&gt;i+1，下一个分叉路继续探寻，标记新建数组或在已有点上。 如果达到终点，就print(ans); return。 如果搜索超时，可以考虑进行剪枝，以避免搜索不满足约束条件的路径。 这样说来，==递归中的递归式就是岔道口，而递归边界就是死胡同==， 123456789101112131415161718192021222324252627282930#示例代码：19930寻宝counter = -1ans = []def dfs(x, y): global mx, counter, m, n, ans counter += 1 if y &gt;= m or x &gt;= n or y &lt; 0 or x &lt; 0 or mx[y][x] == 2: # 遇到递归边界，回到上一个分岔路口。 counter -= 1 # 步数记得回溯！🤓 return if mx[y][x] == 1: ans.append(counter) counter -= 1 return steps = [(0, -1), (0, 1), (1, 0), (-1, 0)] mx[y][x] = 2 # 标记岔路口，免得又探回头😡 for step in steps: # 沿着不同的分叉路，继续前进！💪🏻 dfs(x+step[0], y+step[1]) # 回溯 mx[y][x] = 0 counter -= 1m, n = map(int, input().split())mx = []for r in range(m): mx.append(list(map(int, input().split())))dfs(0, 0) # 从起点开始走print(min(ans) if ans != [] else 'NO') 广搜 BFS【图转树】① 定义队列 q，并将起点 s 入队。 ② 写一个 while 循环，循环条件是队列 q 非空。 ③ 在 while 循环中，先取出队首元素 top，然后访问它（访问可以是任何事情，例如将其输出）。访问完后将其出队。 ④ 将 top 的下一层结点中所有==未曾入队==的结点入队，并标记它们的层号为 now 的层号加 1，同时设置这些入队的结点已入过队。 ⑤ 返回 ② 继续循环。 强调：在 BFS 中设置的 inq 数组【inq数组一般开到“遍历”的所有可能】的含义是==判断结点是否已入过队==，而不是结点是否已被访问。区别在于:如果设置成是否已被访问，有可能在某个结点正在队列中、但还未访问时由于其他结点可以到达它而将这个结点再次入队，导致很多结点反复入队，计算量大大增加。因此 BFS 中让每个结点只入队一次，故需要设置 inq 数组的含义为结点是否已入过队而非结点是否已被访问。 入队了一定会被访问，因此要从入队开始卡人，才及时。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 示例代码：02802小游戏伪AC代码，只计算了步数，未换算成线段数from collections import dequedx = [0, 0, 1, -1]dy = [1, -1, 0, 0]def bfs(): global x1, y1, x2, y2, board, w, h r, c = len(board), len(board[0]) inq = [[False for cc in range(c)] for rr in range(r)] # “入过队”标记们 # 初始化 q = deque() q.append((x1, y1)) inq[y1][x1] = True step = 1 while True: if len(q) == 0: return 'impossible' # 没有“下一级节点”了，证明遍历完还不合题意，没法子了 for _ in range(len(q)): top = q.popleft() # 一个步骤，要遍拿出这一级的所有节点才算 for i in range(4): next_x = top[0] + dx[i] next_y = top[1] + dy[i] if (next_x, next_y) == (x2, y2): return step #“下一级”符合题意了，return！ if 0 &lt;= next_x &lt; w+2 and 0 &lt;= next_y &lt; h+2 and board[next_y][next_x] != 'X' and not inq[next_y][next_x]: inq[next_y][next_x] = True # “下一级”虽然不合题意，但还没遍历完，加到q里，待下一步考量！ q.append((next_x, next_y)) step += 1while True: w, h = map(int, input().split()) if w == h == 0: break ipt = [['']+list(input())+[''] for _ in range(h)] #print(ipt[0]) board = [['']*len(ipt[0])]+ipt+[['']*len(ipt[0])] #print(board) while True: x1, y1, x2, y2 = map(int, input().split()) if x1 == y1 == x2 == y2 == 0: break print(bfs()) 二分查找/二分法/双指针二分查找使用条件：**==① 有序序列；==**② 数据量适中，太小提升少，太大 MLE； 123456import bisectli = [1,2,3,4,5,6]bisect.bisect_left(li, 4, lo, hi, key)bisect.bisect_right(li, 4, lo, hi, key) # = bisect.bisect()bisect.insort_left() # 参数相似bisect.insort_right() = #bisect.insort() 时间复杂度 $O(\\log n)$。二分查找代码实现 12345678910111213141516171819arr = [1,2,3,3,3,4,5]num = 5def binary_search(arr, num): left, right = 0, len(arr)-1 counter = 0 while left &lt;= right: counter += 1 mid = (left + right) // 2 if num &lt; arr[mid]: right = mid - 1 elif num &gt; arr[mid]: left = mid + 1 else: # arr[mid] == num # print(f'查找了{counter}次') return f'值{num}已找到，索引值为{mid}' print(f'查找了{counter}次') return f'值{num}未找到'print(binary_search(arr, num)) 双指针 本质还是遍历。但通过双指针，证明好了，可以 左右指针：需要两个指针，一个指向开头，一个指向末尾，然后向中间遍历，直到满足条件或者两个指针相遇。 快慢指针：需要两个指针，开始都指向开头，根据条件不同，快指针走得快，慢指针走的慢，直到满足条件或者快指针走到结尾。 后序指针：常规指针操作是从前向后便利，对于合并和替换类型题，防止之前的数据被覆盖，双指针需从后向前便利。 ==记忆口诀：左右指针中间夹，快慢指针走到头，后序指针往回走== 做形如 n 数之和——双指针！ 思路： 注意点 while 的条件不会继承。大 while 内的小 while 还得限制 L&lt;R，否则会一下子就不满足大 while 条件，可能导致报错（IndexError）。数据0 0 0 做好输出：就算没法走arr[i] &gt; 0的输出（考虑全 0），也得输出当前累计的counter值。数据0 0 0 0 12345678910111213141516171819202122232425262728293031# 三数之和arr = list(map(int, input().split()))n = len(arr)arr.sort()def Sum3(arr, n): counter = 0# 无需特判 for i in range(n-1): if arr[i] &gt; 0: return counter if i &gt; 0 and arr[i] == arr[i-1]: continue L = i+1 R = n-1 while L&lt;R: if arr[i] + arr[L] + arr[R] == 0: counter += 1 while L &lt; R and arr[L] == arr[L+1]: L += 1 while L &lt; R and arr[R] == arr[R-1]: R -= 1 R -= 1 L += 1 elif arr[i] + arr[L] + arr[R] &gt; 0: R -= 1 else: L += 1 return counterprint(Sum3(arr, n)) 贪心【OJ02431 expedition】这个题就需要一些思维上的转换了。直观上看应该每次加尽量多的油，但是在哪个范围里选最多呢？这里有一种看法：每次路过一个加油站就把油全拿上，但是不加；每次没油的时候再挑一桶加，这个时候挑的一定是目前手上最多的，于是问题迎刃而解。 这种“延迟操作”的思考方式在某些时候是很有用的。 【26971 分发糖果】：两次遍历方法，使得序列既满足“左规则”，又满足“右规则” 从左往右遍历，使得对于 cds[i]，其与右边的元素 cds[i+1] 的关系总符合题意“谁大就谁分的多”。但要注意，此时对于 cds[i]，其与左边的元素不一定满足题意。 从右往左遍历，使得对于 cds[i]，其与左边的元素 cds[i-1] 的关系总符合题意“谁大就谁分的多” 【CF1000B: Light It Up（前缀和思想）】：有一台灯，这个灯在时间为$0$时打开，$m$时关闭，在$0$到$m$这段时间内有$n$个时间点灯的状态会改变（即开变关，关变开），在哪里插个点，使得这个灯亮着的时间最大。1）如果不插点，亮着的时间就是 所有 $i, i+1$ 的区间长度和。 困难在于：如何解决“插点改变状态”后，开、关操作对应索引值的奇偶性逆转的问题。 在插点后，“开”区间平移变为 $i+1,i+2$ ，并增加 $插点, i$ 。如果对于每次插点操作，都要重新计算“开”区间总长度，时间复杂度是 $O(n^2)$，对于 $n=10^5$ 的数量级无法承受。 解决方法：前缀和思想。思路是，新建“前（后）缀和”数组 pix = []： pix中索引为 $i = 2k(k\\in\\Z^+)$ 的值，代表从前往后累计的，所有 $i, i+1$ 的区间长度和； pix中索引为 $i = 2k-1(k\\in\\Z^+)$ 的值，代表从后往前累计的，所有 $i, i+1$ 的区间长度和。 这样，对于每次插点操作（插在 索引值为奇数 $j$ 的项 前面），“开”区间总长度则可用 $O(1)$ 的操作计算，公式为： $$\\text{len} &amp;=&amp; \\text{pix}[j-1] + \\text{pix}[j+2] + [插点,i] \\ &amp;=&amp; \\text{pix}[j-1] + \\text{pix}[j+2] +(\\text{tds}[j+1]-\\text{tds}[j]-1)$$ 为什么是 j+2 不是 j ？因为要挖掉 插点 所在的那个区间，同时增加 $插点, i$ 。 【18164 剪绳子（哈夫曼编码 Huffman 思想）】：剪绳子就是拼绳子，在一定的操作次数下，每次选择最短(heappop)的两段绳子拼起来，拼后压回绳组(heappush）。 ==以谁为参照系，遍历谁？？？== 区间覆盖问题区间合并给出一堆区间，要求合并所有有交集的区间 （端点处相交也算有交集）。最后问合并之后的区间个数。 【步骤一】：按照区间左端点从小到大排序: 【步骤二】：维护前面区间中最右边的端点为ed。从前往后枚举每一个区间，判断是否应该将当前区间视为新区间。 假设当前遍历到的区间为第i个区间 $[l_i, r_i]$，有以下两种情况： $l_i\\le ed$：说明当前区间与前面区间有交集。因此不需要增加区间个数，但需要设置 $ed=\\max(ed, r_i)$。 $l_i\\ge ed$：说明当前区间与前面没有交集。因此需要增加区间个数，并设置 $ed=\\max(ed, r_i)$。 选择不相交区间给出一堆区间，要求选择尽量多的区间，使得这些区间互不相交，求可选取的区间的最大数量。这里端点相同也算有重复。 【步骤一】：按照区间右端点从小到大排序。 【步骤二】：从前往后依次枚举每个区间。 假设当前遍历到的区间为第i个区间 $[l_i,r_i]$ ，有以下两种情况： $l_i\\le ed$：说明当前区间与前面区间有交集。因此直接跳过。 $l_i&gt;ed$：说明当前区间与前面没有交集。因此选中当前区间，并设置 。 区间选点给出一堆区间，取尽量少的点，使得每个区间内至少有一个点（不同区间内含的点可以是同一个，位于区间端点上的点也算作区间内）。 这个题可以转化为上一题的求最大不相交区间的数量。 对于这些最大的不相交区间，肯定是每个区间都需要选出一个点。而其他的区间都是和这些选出的区间有重复的，我们只需要把点的位置选在重合的部分即可。 也可以换一种思路： 我们将区间按照右端点从小到大排序，这时我们应该尽量选择当前区间最右边的点。 因为最右边的点可能和下面的其他区间重复，所以至少不比选择区间靠前位置的点差。 所以，最后的解法与选择不相交区间问题解法完全一样。 区间覆盖给出一堆区间和一个目标区间，问最少选择多少区间可以覆盖掉题中给出的这段目标区间。 【步骤一】：按照区间左端点从小到大排序。 【步骤二】：从前往后依次枚举每个区间，在所有能覆盖当前目标区间起始位置start的区间之中，选择右端点最大的区间。 假设右端点最大的区间是第$i$个区间，右端点为 $r_i$， 最后将目标区间的 start 更新成 $r_i$ 区间分组区间分组问题大概题意就是：给出一堆区间，问最少可以将这些区间分成多少组，使得每个组内的区间互不相交。 【步骤一】：按照区间左端点从小到大排序。 【步骤二】：从前往后依次枚举每个区间，判断当前区间能否被放到某个现有组里面。 （即判断是否存在某个组的右端点在当前区间之中。如果可以，则不能放到这一组） 假设现在已经分了 $m$ 组了，第 $k$ 组最右边的一个点是 $r_k$，当前区间 $i$ 的范围是 $[L_i, R_i]$。则： 如果 $L_i\\le r_k$ ，则表示第 $i$ 个区间无法放到第 $k$ 组里面。 反之，如果 $L_i&gt;r_k$， 则表示可以放到第 $k$ 组。 如果所有 $m$ 个组里面没有组可以接收当前区间，则当前区间新开一个组，并把自己放进去。 如果存在可以接收当前区间的组 $k$ ，则将当前区间放进去，并更新当前组的 。 注意： 为了能快速的找到能够接收当前区间的组，我们可以使用优先队列 （小顶堆）。 优先队列里面记录每个组的右端点值，每次可以在 的时间拿到右端点中的的最小值。 【27104 世界杯只因】：如何以尽可能少的摄像头，覆盖尽可能多的区域。 初始化 结果数组 各处均为 0。 结果数组每一位的值，表示 范围要覆盖到这里所需要的最少摄像头数目； 初始化的 0 表示 此处无法被覆盖到。 每一次： 对于第一个没被覆盖到的点，寻找一个摄像头，使得这个摄像头： 能覆盖到这个点 （==不一定在这个点上！==） 最省心——能覆盖尽可能多的区域（即右边界最大），这样下一次就可以节省摄像头 找到这个摄像头后，把这个摄像头覆盖的所有区域的值 都更新为所需的最少的摄像头数目。 下一次寻找没被覆盖到的点时，从这个摄像头的右边界开始寻找即可。 这个算法对于任给一族区间要找最小覆盖的问题都对。 【Radar Installation】：我们可以逆向思维来贪心。首先我们已经知道一个贪心模板——最小区间覆盖，且这题也很像它，那么我们就把这题转成这个模板。 我们发现可以覆盖某个小岛的雷达在海岸线上的坐标呈一条线分布。那么我们就把这一段线看成一段区间，用雷达覆盖所有区间。由勾股定理得第 $i$ 个小岛的区间为： $(x−sqrt(d∗d−y_i∗y_i),x+sqrt(d∗d−y_i∗y_i))$ 那么我们再按最小区间覆盖的做法，将右端点从小到大排序，然后取点，结束。 数学素数筛法——欧拉筛 123456789101112131415161718192021def pre(n): pri = [] not_prime = [False] * (n + 1) for i in range(2, n + 1): if not not_prime[i]: pri.append(i) for pri_j in pri: if i * pri_j &gt; n: break not_prime[i * pri_j] = True if i % pri_j == 0: &quot;&quot;&quot; i % pri_j == 0 换言之，i 之前被 pri_j 筛过了 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被 pri_j 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break 掉就好了 &quot;&quot;&quot; break print(pri) OJ01218:THE DRUNK JAILER：能够拨动奇数次的开关，必然是因子个数为奇数的开关。而因子个数为奇数，一定是完全平方数。因为因子是成对出现的，只有完全平方数才会有一个独自的因子。如 $36\\to(1,36),(2,18),(3,12),(4,9),6=7$ 个因子。 OJ01008: Maya Calendar：注意取模 $\\in[0,除数-1]$，而题中日历 $\\in[1,除数]$ defaultdict 使用方法 assignment9 好多没做，矩阵卷积运算 01922: Ride to Schoolhttp://cs101.openjudge.cn/practice/01922/ 思路： 虽然是追及问题，但注意时间变化的连续性。不可用 t += 1 模拟时间变化。 向上取整 math.ceil() ==Charley 一定和某人一起到。== 脑筋急转弯 买学区房接收数据 pairs = [i[1:-1] for i in input().split()]distances = [ sum(map(int,i.split(‘,’))) for i in pairs] http://cs101.openjudge.cn/practice/19963 递归方法的技巧——想要一直往前冲，不回头，就把 n 弄成全局变量，而非函数的参数。【波兰表达式】 题目数据没说保序，就必须排序！ 其他OJ02707: 求一元二次方程的根 OJ4146：数字方格：math OJ02746: 约瑟夫问题 CF96A ![image-20231209210959489](/Users/liangzhong/Library/Application Support/typora-user-images/image-20231209210959489.png) 树状数组、线段树（期中阶段の补充） 确实，dijksta 可以套 bfs 的堆写法模板 ==dfs——把传入数据写到 def 上？TA-Hu Yang== ==dp——模版？== 优先队列？？？？——顺序会改变！ from colletions import deque，双端队列，两边出数都快 背包问题 dp 模版！！！ CF230B、DrunkJailor 宽搜——heapq!!!//quene!!!(先进先出) 宽搜用字典记录也可，字典套 tuple，vis=dict() all() 作业 没做出来的题目 3 装箱问题 4 CF1364A: XXXXX、OJ04146: 数字方格 5 12559: 最大最小整数 v0.3、230B. T-primes 6 生存游戏 7 1793C. Dora and Search、368B. Sereja and Suffixes 8 (Nov 月考) 23566: 决战双十一 9 几乎没做 A 认真看， https://codeforces.com/contest/455/problem/A B√ 摆动数列 C√ 乌鸦坐飞机——装箱问题 D√ over，最多差一个 2050 成绩计算 打魔兽 set dict 双指针 能过 回溯 全排列、八皇后，生成方案，遍历方案 装箱——题解 Numpy× 经典问题OJ25353: 排队Greedy, http://cs101.openjudge.cn/practice/25353/ 有 $N$ 名同学从左到右排成一排，第 $i$ 名同学的身高为 $h_i$。现在张老师想改变排队的顺序，他能进行任意多次（包括 0 次）如下操作： - 如果两名同学相邻，并且他们的身高之差不超过 $D$，那么老师就能交换他俩的顺序。 请你帮张老师算一算，通过以上操作，字典序最小的所有同学（从左到右）身高序列是什么？ 输入 第一行包含两个正整数 $N, D (1≤N≤10^5, 1≤D≤10^9)$。接下去 $N$ 行，每行一个正整数 $h_i (1\\le h_i \\le 10^9)$ 表示从左到右每名同学的身高。 输出 输出 $N$ 行，第 $i$ 行表示答案中第 $i$ 名同学的身高。 样例输入 1234565 377362 样例输出 1234567723 提示 【样例解释】一种交换位置的过程如下：7 7 3 6 2-&gt; 7 7 6 3 2-&gt; 7 7 6 2 3-&gt; 7 6 7 2 3-&gt; 6 7 7 2 3 OJ01017: 装箱问题greedy, http://cs101.openjudge.cn/practice/01017 一个工厂制造的产品形状都是长方体，它们的高度都是 h，长和宽都相等，一共有六个型号，他们的长宽分别为 1*1, 2*2, 3*3, 4*4, 5*5, 6*6。这些产品通常使用一个 6*6*h 的长方体包裹包装然后邮寄给客户。因为邮费很贵，所以工厂要想方设法的减小每个订单运送时的包裹数量。他们很需要有一个好的程序帮他们解决这个问题从而节省费用。现在这个程序由你来设计。 输入：输入文件包括几行，每一行代表一个订单。每个订单里的一行包括六个整数，中间用空格隔开，分别为 11 至 66 这六种产品的数量。输入文件将以 6 个 0 组成的一行结尾。 输出：除了输入的最后一行 6 个 0 以外，输入文件里每一行对应着输出文件的一行，每一行输出一个整数代表对应的订单所需的最小包裹数。 解题思路：4*4, 5*5, 6*6 这三种的处理方式较简单，就是每一个箱子至多只能有其中 1 个，根据他们的数量添加箱子，再用 2*2 和 1*1 填补。1*1, 2*2, 3*3 这些就需要额外分情况讨论，若有剩余的 3*3,每 4 个 3*3 可以填满一个箱子，剩下的 3*3 用 2*2 和 1*1 填补装箱。剩余的 2*2，每 9 个可以填满一个箱子，剩下的与 1*1 一起装箱。最后每 36 个 1*1 可以填满一个箱子，剩下的为一箱子。 样例输入 1230 0 4 0 0 17 5 1 0 0 00 0 0 0 0 0 样例输出 1221 来源：Central Europe 1996 【张概论，中国语言文学系，2023 年秋】 ==（请改为同学的姓名、院系）== 思路：==（请改为同学的思路和代码）== 用时至少 3 个半天（早上/中午/晚上） 代码1234567891011121314151617181920212223242526272829303132333435## OJ1017: 装箱问题def num_2(li): rest_3_2 = [0, 5, 3, 1] rest_3_1 = [0, 7, 6, 5] rest_more_2 = [0, 8, 7, 6, 5, 4, 3, 2, 1] space_2_4 = li[4] * 5 space_2_3 = rest_3_2[li[3] % 4] if li[2] - space_2_4 &lt;= 0: return [0, ((space_2_4 - li[2]) + space_2_3) * 4] elif li[2] - space_2_4 &gt; 0 &gt;= li[2] - (space_2_4 + space_2_3): return [0, rest_3_1[li[3] % 4] + ((space_2_4 + space_2_3) - li[2]) * 4] elif li[2] - (space_2_4 + space_2_3) &gt; 0: return [-(-(li[2] - (space_2_4 + space_2_3)) // 9), 4 * rest_more_2[(li[2] - (space_2_4 + space_2_3)) % 9] + rest_3_1[li[3] % 4]]def num_1(li, a): rest = a[1] + li[5] * 11 if li[1] - rest &lt;= 0: return 0 elif li[1] - rest &gt; 0: return -(-(li[1] - rest) // 36)def pack(li): a = num_2(li) return li[6] + li[5] + li[4] + (-(-li[3] // 4)) + a[0] + num_1(li, a)all_order = []while True: a, b, c, d, e, f = map(int, input().split()) if a == b == c == d == e == f == 0: break else: all_order.append([0, a, b, c, d, e, f])for i in range(len(all_order)): print(pack(all_order[i])) 代码运行截图 ==（AC 代码截图，至少包含有”Accepted”）== ![image-20230930184820898](/Users/liangzhong/Library/Application Support/typora-user-images/image-20230930184820898.png)","link":"/2024/02/16/cheetsheet-for-cs101/"},{"title":"Easy-use Terminal","text":"终端里常用的软件，以及常用 GUI 软件在 Terminal 下的平替。可供查询。 常规用法 常规用法 应用 可视化的文件管理器 ranger 多彩的文本编辑器 nano(写作)，vim(编程) 多彩的 Markdown 查看器 glow 邮件收发 mutt,msmtp,fetchmail,procmail 组合 网页浏览 lynx 或者一个基于 docker 的可视化浏览器(github) 人工智慧支持 tgpt(github) 词典翻译 wd(无道词典, github) 科学知识 clash 微信命令行版本 wechatcmd 微信聊天记录总结机器人 ？ 网易云音乐（基于Web端） musicfox 图片、pdf显示 viu, 或者 lslx 项目 文字版pdf转html并显示 pdf2html + w3m 表格处理 sc 自动补齐插件: aspell 文字版pdf转html，效果并不太好，而且html也是纯文本。比较难受的点是，这样转换出来的html断行是非常不自动的。最好还是找到「电子书」格式的电子书（一般有能转换pdf版本的电子书，都有更「数位化」格式），用Calibre 软体下的ebook-convertor [Input File] [Output File]解包为多个 html 文件来阅读（如 epub 等）。 网络连接 网络用法 应用 显示当前局域网 IP、公网动态 IP curl cip.cc 与 ifconfig 开启服务器功能 (1)作为局域网内下载服务器：http-server; (2)利用 ssh + scp 作为上传 &amp; 下载服务器; (3)作为git服务器 作为备份服务器 用 rsync -r 进行（初次）差异备份，rsync -avur --progress --delete &lt;local&gt; &lt;remote&gt;参考：https://www.cnblogs.com/sunsky303/p/11775432.html 系统检测 监测项目 应用 全局监测 conky, top, powertop(功耗) 网速 speedtest-cli, 运行 speedtest 命令；nload 一些 Github 项目地址 Github 项目 地址 基于 docker 的可视化浏览器 (在 Mac 上要首先安装 colima 进入虚拟 ubuntu 环境，即运行前两行代码) tgpt https://github.com/aandrew-me/tgpt, curl -sSL https://raw.githubusercontent.com/aandrew-me/tgpt/main/install | bash -s /usr/local/bin wd https://github.com/maxzhx/WuDaoDictionary，但由于是爬虫技术，所以可能不太稳定 wechatcmd go get -u github.com/liushuchun/wechatcmd musicfox brew install anhoder/go-musicfox/go-musicfox lsix 项目 操作方法微信简介(见下) 注释 [1] 123brew install docker colimacolima startdocker run --rm -ti fathyb/carbonyl https://github.com/fathyb/carbonyl [2] lsix 项目——操作方法微信公众号简介：https://mp.weixin.qq.com/s?__biz=MzU3NTgyODQ1Nw==&amp;mid=2247485577&amp;idx=1&amp;sn=481418e5efdfd0b06095c6e07d890628&amp;chksm=fd1c700fca6bf9194a6657ab06562f4f0890967d7491880804d0c9aa08a983ee1ab14a4daf34&amp;token=1994080286&amp;lang=zh_CN#rd [3] which : 寻找软件包所在地 [4] 非 Homebrew 安装的包，如何卸载 Uninstalling? 1sudo rm $(which tgpt)","link":"/2024/02/02/easyuse-terminal/"},{"title":"Android Termux 环境下 ubuntu 安装、配置与用法","text":"倒腾札记: Android Termux 环境下 ubuntu 安装、配置与用法 想要把手机变成小主机，毕竟安卓也是基于 Linux 的，无意间发现安卓手机上可以用 Android Termux 弄成衣蛾 ubuntu 安装 安装 F-droid 开源商店 从 F-droid 中下载 Termux 和 AnLinux 按照 AnLinux 提示安装 ubuntu 安装 KDE 桌面环境（Xfce4 似乎会出错？） ubuntu 配置与用法 建议新建管理员账户并使用之，尽量不使用 root 账户。root 账户也要记得修改密码并记住。 安装基本软件：Chromium, WPS Office, VSCode, Sougoupinyin。都要挑选 arm64 版本。 WPS Office, VSCode 安装顺利。 sudo apt-get install &lt;package_name&gt; 安装源里的软件包，sudo dpkg -i 安装本地下载的 deb 包， aptitude 强大的软件包管理器 sudo apt-get remove/autoremove &lt;package_name&gt; 删除 sudo apt-get -f install 或 sudo apt --fix-broken install 自动化解决依赖关系问题 wget/curl/git clone 下载网络上的文件 踩坑： 由于 anlinux 安装的 ubuntu 不知为何 snap 一直无法安装，而像 Firefox, Chromium 等浏览器等类应用，如果只通过命令行安装，就需要使用 snap，因此要换种思路，下载 .deb 包并使用 deb 包管理器 dpkg -i 安装。 此外，发现对于 Ubuntu 22.04 (maybe not LTS) 及其所配置的源，Firefox &amp; Chromium 最新版的 .deb 包安装过程中均会出现依赖关系问题（部分软件包版本较老）。尝试使用 sudo apt-get -f install 解决，发现电脑要求删除；尝试使用 sudo apt --fix-broken install 无果；尝试使用 sudo apt-get update 却无法自动升级（应该是源里的包最新就到这个版本）；换 Tsinghua 源、UTSC 源均无果。 无奈只能寻找老版本软件包。安装成功了。 ==总结：电脑要求删除就别硬钢了！说明依赖关系电脑自动化程序解决不了了。尝试换低版本的 deb 包== 注意：dpkg 后加 –ignore-depends 可以忽略依赖【慎用】 配置基于 fctix 的 搜狗输入法【尚未完成】。 Termux Linux 基础命令Termux 软件包管理除了apt命令，Termux 还提供pkg命令进行软件包管理。 12345678# 安装软件包$ pkg install [package name]# 卸载软件包$ pkg uninstall [package name]# 列出所有软件包$ pkg list-all 其实，pkg的底层就是apt，只是运行前会执行一次apt update，保证安装的是最新版本。所以，apt install sl基本等同于pkg install sl。 Termux 支持的软件包清单，可以到这里查看。 Termux Linux 基础命令 (Ed. 1)cd：(切换)vim:(创建文件） vi：编辑文件bc：（计算器）quit：退出计算器mkdir：（创建目录） mkdir -p：递归建立目录rmdir：（删除目录）arch：（显示处理器X86）hostname：（显示系统名称）who：（显示目前登陆用户的信息）cat：（查看文件） more：（查看全部内容）ls：（查看当前目录或文件）pwd：（显示当前位置）date：（显示当前日期和时间）logout：（注销）reboot；（重启） init 6 :(重启）inito：（关机）rm:(删除） rm -rf：（删除任何文件）echo：（回显内容）touch：（创建文件） touch 。 。 。：（创建在同意目录下多个文件）wc -l：（查看文件数量或文件行数）tail：（查看文件倒数十列）tac:(文件倒序）head：（查看文件前十行） head -。：（加-几就显示几行）grep：（过滤） 参考：cat 123 | grep 我在家passwd：（更改用户密码) passwd root:(指定更改用户密码）df：（查看磁盘使用情况）top：（查看内存，CPU性能）Netstat：（显示各种网络相关信息） （光驱）（目录）mount：（挂载本地文件或磁盘） 参考：mount/dev/sr0 /optUmount：（删除挂载）free：（查看内存使用情况） （文件名）（目录名）mv：（移动文件或目录） 参考：mv 123 nihao （ 参数） （ 文 件 名 )find:(查找） 参考：find 路径 -name ifcfg-eth0su:(切换用户）EXIT:(退出登录）userdel：（删除用户） 参考：userdel 123graupadd：（创建组名）groupdel：（删除组）iostat：（查看磁盘状态）（导出）（文件名）（安装包）sz：（导出文件） 参考：sz 123 lrzszyum install：（安装软件包）tar xvf 文件名·tar·gz ：（解压） nginx：（服务安装包）Unzip：（解压以zip结尾的文件）ps -Aux：（查看当前运行的进程）wget：（下载）wget 下载东西的链接du：（查看文件或目录大小）kill：（杀掉） 参考：kill 1231clear：（清屏）（月）（年）cal：（显示日历） 参考：cal 4 2016cp：（复制） （属性） ( 文 件 名 ）chmod：（修改文件权限） 参考： chmod 357 123.txt （文件名）chwon：（修改文件属主属组） 参考：chown 123：321 123 （属主）（属组） Linux中一些基础命令 (Ed. 2)(1) pwd：显示当前所在位置的绝对路径 (2) cd+路径：切换当前工作位置 (3) cd . ：退回到当前位置 (4) cd .. ：退回到上一层 (5) ls：默认显示当前位置当前目录下的内容 (6) clear ：清屏，相当于翻页 (7) cd ~ ：直接进入到当前用户的家目录 (8) cd - ：切换到上一次所在位置，在两个位置间来回切换 (9) mkdir + 文件名：创建一个目录（文件夹） (10) touch + 文件名：创建一个普通文件 (11) man ：查看帮助手册 （1）代表命令（2）代表系统调用（3）代表库函数 例：man printf ：查询命令printf man 3 printf ：查询库函数printf (12) rm：删除文件（删除目录文件用 rm -r） rmdir 目录名：删除空目录 rm -r 目录名 ：删除非空目录 (13) cp：拷贝文件 拷贝普通文件： cp 源文件的路径+文件名 目的路径 拷贝目录文件： cp -r 源目录文件路径+目录名 目的路径 拷贝+重命名： cp 源文件路径+文件名 目的文件+文件名 思考：cp -r 目录文件 tmp1 执行两次，两次结果为何不同？ 代码示例： 第一次执行 tmp1目录文件不存在，所以是拷贝dir123文件并重命名为tmp1；第二次执行已经存在tmp1文件，将tmp1当成路径，将dir123拷贝到tmp1目录下 (14) mv：剪切文件 移动普通文件：mv 源文件路径+文件名 目的路径 移动目录文件：与移动普通文件一样，不需要加-r 剪切并重命名： mv 源文件路径+文件名 目的路径+新文件名 重命名：mv 源文件路径+文件名 源文件路径+新文件名 (15) find：查找 find 搜索路径 -name 文件名（按文件名搜索） find 搜索路径 -cmin -n(搜索过去几分钟内修改的文件) find 搜索路径 -ctime -n（搜索过去几天内修改的文件） (16) grep：在文件中过滤出包含制定字符串的行 grep 字符串 文件名 (17) | ：管道命令 将前一个命令的输出结果作为后一个命令的输入，一般与过滤结合使用。例：ls | grep test ls \\bin | grep sh (18) wc :统计文件中单词的个数（-w），字符的个数（-c），行数（-l） wc -w 文件名 wc -c 文件名 wc -l 文件名 (19) su :切换用户 sudo su ：切换为管理员 退出：exit su 用户名：切换为其他用户 退出：exit (20)关机与重启 shut down -h now ：立刻关机 halt：关机 init 0 ：关机 shut down -r now ：立即重启 reboot：重启 init 6 ：重启 (21) 查看系统运行级别 0:关机 1:单用户模式 2:多用户无网络服务 3:完全的多用户 文本界面 4.未定义或自定义 5.图形化界面 6.重启 (22) 其他命令及小知识点 1.tab补全,按上下键查阅执行过的命令 2.ctrl - 调小窗口 ctrl +shift+ + 调大窗口 3.Ctrl+Alt: 释放鼠标 4.history: 查看终端的所有的历史命令","link":"/2024/01/24/ubuntu-in-termux/"},{"title":"个人 Git 仓库使用设置","text":"目标 将旧手机 iQOO 3 用作个人 Git 仓库服务器，实现私有化。 （不一定能实现）将服务器接入公网，实现真远程访问。 实现方式服务器设置 用 AnLinux 在 Android Termux 上安装 ubuntu 设置./start-ubuntu自启动： 123$ cd /data/data/com.termux/files/usr/etc/$ vim termux-login.sh# 添加语句： ./start-ubuntu 进入 ubuntu 后，安装vim, git, ssh等必要的包。如果安装出现类似code (1)的错误，则先apt update+apt upgrade，后安装。 新建用户 git 并设置密码，（然后编辑/etc/passwd使 git 无法访问终端，提高安全性—此操作似乎有问题）。注意：设置密码一定要在阻断终端之前！ 12345$ su git# 按要求设置密码$ exit$ vim /etc/passwd# 将文档中 git:x:1000.../bin/bash 改成 .../bin/git-bash 移动到想要作为远程 Repo 的目录，输入以下指令初始化并赋权 12$ sudo git init --bare .$ chown -R git:git /root/repository/mainRepo #也就是目录 启动 ssh 服务 （第一次操作以后，只需要管理 ssh 即可） 12$ /usr/sbin/sshd -p 端口号# 如果出现无法访问某目录，则尝试访问之，如无则手动创建，如有则手动赋权 对于 ssh 服务的管理 启动 ssh 服务：除了上面的指令，还可以用如下指令实现。但不知端口设置如何。1$ service ssh start # 要关闭，就用 stop 查看 ssh 服务状态1$ service ssh status 至此，服务器的设置结束，该终端已被设置为可用的 git 服务器。 客户端访问1$ git clone ssh://git@serverip:port/path","link":"/2024/01/23/personal-git-repo/"},{"title":"《利维坦》读书笔记","text":"文／秋 草 从利维坦到新政治科学霍布斯进一步发展了培根的经验主义，并以此作为自己的自然哲学根基。但是，霍布斯并不志于描绘出一套至善的认识论体系，他所关心的是从基本的元素推导出宏观的结论。虽然其本身并未作出系统的逻辑学阐释，但是霍布斯一再强调推理的意义，并通过《利维坦》这部政治哲学著作作出了生动的实践范例。在霍布斯的思想中，自然哲学只是一块垫脚的砖石，他真正在意的是一种不同于伦理学的 “公民哲学”。通过对人性的定义和演绎，霍布斯描绘出了 “自然状态”，以此解释社会契约的产生和主权国家的形成。值得注意的是，霍布斯用人性阐释政治，这消解了伦理的政治实践意义，将神学放逐出政治理论，并以尖锐的笔锋挑战教会和经院哲学的权威。不仅如此，霍布斯还在哲学上对经院哲学的目的论进行批驳，他的观点也在意识形态领域为英国新兴的资产阶级和新贵族作出了利己主义式的理论辩护。在英国资产阶级革命的历史期间，霍布斯鼓吹绝对专制主义，又开自由主义与个人主义的先河，这何尝不是一种 “海日生残夜” 的矛盾对立。某种程度上，“自然状态” 的现实投影其实是英国革命期间的军事动乱与人民暴动，对此深感恐惧的霍布斯极力论证了 “死亡是人类最大的恐惧”，并由此推导出其希望的消极和平。可以说，作为资产阶级革命的过渡形式，克伦威尔的军事独裁和拿破仑的第一帝国是霍布斯笔下 “利维坦” 的政治实践。 将视域框定到现在，我们也许需要思考霍布斯留下的思想遗产存在何种的转译可能。毫无疑问，专制制度早已扫进历史的垃圾堆，但是霍布斯对国家产生的解释仍然具有警示意义。在当时，神权国家概念占据主导地位，奥古斯丁的 “双国” 观念强调上帝之国高于地上之国，阿奎那则从国家起源和国家目的两方面将国家神化。而后的马基雅维利第一次冲击了神权国家观念，伴随着现代国家观念的出现以及民族国家的逐渐形成，以霍布斯为代表的思想家主张国家的合法性来源于人民的授权。从 “君权神授” 到 “君权民授” 的转变预示了某种现代性的前夜，而在当下，对国家的神话建构更需要考虑一个必要的命题：人民权利与国家权力的平衡。只有政治秩序（civil order）不凌驾于公民权利之上时，自然状态的恐慌才不会在某种例外状态下被重现。 《利维坦》中的人私人感觉 —— 对人类官能的解构作为开篇，《利维坦》的第一部分《论人类》首先通过建构一种具有唯物主义色彩的认知论来解析 “人” 的机能。霍布斯认为，感觉的原因是外部物体或者对象，它们直接或间接地施压于专司一种感觉的器官，而这种压力（pressure）通过神经传达至大脑和心脏，于是人们感觉到表象 “appearance”。霍布斯将感觉的起源归还于客体（object），并通过一种生理性的阐释完成了 “表象” 与 “实在”（reality）的分离。作为培根思想的接受者，也作为一名务实且形而下的英国人，霍布斯在这段认识论的建构中表现出突出的经验主义倾向，他直言 “感觉都不过是原初的幻象（orignal fancy）”，而真正的现实是某种不可达到的客观实在。 心理过程 —— 运动的投射“所有幻象都是我们内在的运动，是感觉中所造成的运动的残留；那些在感觉中直接前后相继的运动，在感觉之后仍然会完整继续下去。” 霍布斯认为感觉运动的过程存在 “过去 —— 当下 —— 未来” 的因果关系，他断言 “想象（imagination）和记忆（memory）是同一回事”，但想象指向观念（idea）或形象（image）本身，而记忆指向衰退（decay）。霍布斯将思想过程称作思维序列，而思维序列存在两类：一类没有引导也没有目的，是思想流走，另一类更加恒定，受到某种欲望和计划的调制（respice finem）。 更一般地说，想象在霍布斯的思想运作图景中起着至关重要的作用。其中一种想象就是我们现在所说的想象，“就像我们时而看到一个人，时而看到一匹马，在脑海中想象出一个半人马”。也就是说，我们可以从不同的经历中获得想法，褪色的感觉，并将它们结合在一起。但是霍布斯也将想象和 “想象的能力” 与记忆和理解紧密联系在一起。 此外，霍布斯认为理解是一种想象，也就是说，想象的能力负责理解以及合成图像和记忆。在此基础中，人类拥有一种特殊的理解能力：从他人的语言使用中理解他们的观念和思想。对语言运作的描述对于他对思想运作的描述至关重要，对于霍布斯来说，心灵（mind）包含了感觉、想象和语言的运作，而没有进一步的理性能力，他否认笛卡尔的非物质心灵（immaterial mind）的存在，随后用语言的观念来填补了思维运作的功能解释。 语言与推理 —— 知识的产生与演绎通过对语词的界定，霍布斯导出了语言的路径。“语言的普遍用途是将心理的探讨转化为言语的探讨，或把思想的序列转化为语词的序列”，“语言的第一用途便在于名称的正确定义，这是科学的获取物；语言的第一滥用则在于定义错误或没有定义，一切假的或无意义的信条都是从这里来的。” 显而易见，霍布斯摈弃了传统价值判断强调善恶的观念，转而关注正确与错误，或者说：” 真和非真 “。 不同于笛卡尔认同的 “天赋”，霍布斯承认后天的训练，某种程度上这是对人类社会性的洞见。霍布斯探讨社会环境对习得（acquire）的影响，“理性不像感觉和记忆那样是与生俱来的，也不像明智那样是单纯从经验得来的，而是通过勤勉得来的。” 所以，霍布斯认为推理是人人都可以习得也人人都应该习得的机能。名称 —— 断言 —— 推论 —— 科学，霍布斯给出了一套标准的逻辑学解释。 科学（science）在中世纪一般被理解为知识，而在现代社会的前夜，科学被赋予了越来越多的现代性意义。“感觉和记忆知识关于事实的知识，这是过去的不可改变的东西，而科学则是关于结果，关于一个事实与另一个事实之间的依存关系的知识。” 在霍布斯的理论中，科学与推理服务于每个人的利益。所以无意义的语词是有害的（不同于非道德的），一个正确的定义或者范式则无意是有益的，这同利维坦当权者的绝对权力相似，一个有效力的统治者必须是务实的。“人心的光明就是清晰的语词，但首先要弄清楚确切的定义，清除含混性”，“书同文，车同轨” 的目的是更稳定的统治，霍布斯的逻辑学表现出明显的实用主义的色彩。 在逻辑学意义上，霍布斯对语言和名词作出了哲学层面的规定，但是又不只是拘泥于形式的规定，他极力推崇理性的推理，并且毫不留情地批判教会和经院哲学生产出来的枯燥文句。对于神学家的空洞言论，霍布斯直斥 “当人们连篇累牍地写些这样的东西时，他们难道不是发了疯或者想使人家发疯吗？“作为反拨，霍布斯认为” 人类的心灵之光就是清晰的语词，但首先要用严格的定义去检验，清除它的含混意义；推理就是步伐，学识的增长就是道路，而人类的利益则是目标。“ 从机械论到自然权利揆诸书的头部，霍布斯毫不掩饰地描绘一种机械式的运动观，虽然霍布斯并非机械论的最早提出者，但是他完成了一项伟大的任务 —— 将神学从政治的机体中放逐。在霍布斯看来，社会的运动与自然的运动相似，力学可以解释自然界的斗转星移，也理所应当地成为人类社会的运作法则。因此，原因获得了第一性，而目的论被霍布斯无情地加以否定。 显然，物质世界只有运动和力的相互作用，世间万物都可以还原成纯粹的量。古典哲学的宇宙观投射至人类社会产生了自然等级秩序，但霍布斯经由机械唯物论的立场推翻了这层构筑。霍布斯建立的本体还原论取消了自然等级秩序，人的理性被还原成复杂的经验，价值追求被还原成欲望。由此视角，纷繁的社会生活只是不断刺激着人的经验与欲望，从而使得人与人之间等价于物与物之间。人的差异不足以产生社会的撕裂，或者说：” 这种量的差别不足以将一个人置于他人之上 “，只要是人就都拥有一定的理性，而人的理性能力只有差异之别，而无高低之分。人的存在由理性和激情构成，而二者均可还原为感觉，感觉又由于人的感官和外界事物的相互作用，一系列的还原导向了人的平等。故而，自然权利论顺理成章地得以确立，自然中没有所谓的等级秩序，也没有何者更加高贵。至此，霍布斯为其意图推演的政治科学构筑了第一层逻辑，即自然权利与人本质上的平等。■","link":"/2024/01/10/%E3%80%8A%E5%88%A9%E7%BB%B4%E5%9D%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:%E7%A7%8B%E8%8D%89/"},{"title":"Charge into 2024","text":"谢谢你的阅读 每个人都有自己的故事。就算朋友圈的排版再图文并茂，别人的生活终究是供品评玩味的他者。大段的文字似乎更不讨喜。如果你愿意阅读下面的文字，我想那一定是我的荣幸。 又是一年年关岁末。 记得去年年末，厦门疫情又起来的时候，我们在一片躁动与混乱加以核酸采集的缓慢中等来了停课的消息。等到大部分人都回去，课程停摆，而我与一帮同学因为是住宿生（尽管家并不远，但住宿生往往可用“回不去家”作为理由），得以苟留在寝室。于是我们得以和生管老师共享寝室自习室希沃上的扫雷，在一个人也没有的无垠的操场上狂奔数圈，体验了因锡纸粉关停而终于不再蒜气熏天的厦大食堂，在高三 13 班的教室里放声歌唱（当然，还尊享了专门驻在学校的核酸检测资源）。日复一日的授课褪去，时间表的规束解开，我何其幸运地品尝到所谓校园生活的滋味。 后来我们也被赶回了家。网课开始了。上网课的时候的懒散是不可为外人道的。房间的窗户朝西，早上的光线要看天公心情；倘若透进来的光线恰好打亮窗前的桌板，那再打开电灯就显得很不必要。即便因为一时的认真打造类同在校的读书环境，但比习题更按时完成的午觉往往也会使吊灯面临失业。所住的房屋并非位于新起的楼盘，待时间来到下午，床铺依然昏暗，不过略一抬头，就是斜射入的晃眼的光，把飘浮着的浮尘镀上银，洒在层次不齐的练习上。偏西的太阳直挺挺地打在电脑的背面，往往偷着日光便能看清琐碎的字迹。无奈补上网课走神的天坑实在过于劳神，总需再挪用一些时间聊以自慰。下午的网课往往早早结束，剩下的分钟还能得到落日的眷顾，后来就喜好在另一件朝西的房间敲几个音符，这便成为每日为数不多的期待。 在这样的期待中熬到了 22 年的最后一天。那天的落日与云笼罩了整个小岛。12 月的厦门免不了有些寒凉，寒凉化作空气中的阴冷窜入鼻息。但太阳却是明艳。虽然免不了冬天的寒凉，免不了时间的流逝，免不了挥手告别过去的一年，但太阳什么也不说。它不过默默地注视着世界，用暖意注释着将来的生活。 在这样的图景中，世界奔向 2023。The world charges into 2023. 23 年经历了许多。世事实在难料，生活实在荒谬。上半年的音乐偏好在摇滚与纯音间激烈摆动，下午起床后和晚上入睡前总借摇滚来控诉借纯音来超脱。春回大地融雪为水《漂流人间》，在《Lights are on》的夏夜则是着背心卧草坪仰望《Echos of the Eyes》；随着万青的脚步重走了一遍千禧年的世界，又从冲绳《Sundaland of mind》的海滩走向 Cyberpunk 的《Midnight City》。我难以回答一场场的考试间我究竟还期待多少美好与奇迹，那些缠绕着复杂心境的回忆在汉语里鲜有词汇对应。我盼望着脱离大地，冲上云霄、直达天际。 下半年我离开家乡的小岛，来到北京。我幸运地逃离了高中的苦海，但又投入了帝都汹涌的人海。夹杂在形色的人群中自觉自己的渺小，但森严的评价体系也不愿放走我这个新来的水滴。不过生活的艺术是忙里偷闲，周末几近定时的夜聊总是淋漓酣畅，一二九排练的放声歌唱还是能洗脱一天的疲累；小岛的好友时常来访，颇感欣慰。一些事，一些人，泛起涟漪，但来日方长，亦不晓前路几何。虽是岁末，但这些日子，或许仍未到总结的时分。 我很感谢你看到这里。 我不想错过今天的夕阳。今天的太阳将沉落于 16 时 58 分，但窗外已经暗淡了。匆匆踏上单车，赶往湖边，勉强抓住了最后的余晖。这时的暖阳素雅许多，是不同于小岛的风情。冰面映着阳光，好像窗前筼筜湖映着 2022 年最后的夕阳。 夜生活是现代人的专利。但太阳落下时，谁可拒日落而息的基因？ 2023 年送我们至此，它将要回它的归处。 生活是无限的琐碎庸常。十八年来，未曾料想，新年伊始的唯一标识，不过是简单披上睡袍，在裹挟着阴冷的木质家居的气息里，睡眼朦胧地瞥见石英钟里内嵌的数码“1 月 1 日”。但今年不可能这样了。这里是北京，现时是期末，明天又会有明天的故事。 但我们正真确地奔向 2024。Let’s charge into 2024. ■ @o0o0o0o 2023-12-31","link":"/2023/12/31/charge-into-2024/"},{"title":"“適” 實詞詞義引申發展脈絡梳理","text":"—— 兼論《史記・貨殖列傳》“小人富以適其力” 中 “適” 的意義與用法 .md-content > .md-typeset h2 { font-feature-settings: 'halt'; text-align: justify; font-family: 'lmroman', '思源宋体 CN'; /* display: flex; */ letter-spacing: 0.05em; text-indent: 2em; margin: 0; padding: 0; font-size: 1em; font-weight: 400; line-height: 1.6em; } .md-content > .md-typeset h3 { font-feature-settings: 'halt'; text-align: justify; font-family: 'lmroman', '思源宋体 CN'; /* display: flex; */ letter-spacing: 0.05em; text-indent: 2em; margin: 0; padding: 0; font-size: 1em; font-weight: 400; line-height: 1.6em; } .md-content > .md-typeset h4 { font-feature-settings: 'halt'; text-align: justify; font-family: 'lmroman', '思源宋体 CN'; /* display: flex; */ letter-spacing: 0.05em; text-indent: 2em; margin: 0; padding: 0; font-size: 1em; font-weight: 400; line-height: 1.6em; } .md-content > .md-typeset h5 { font-feature-settings: 'halt'; text-align: justify; font-family: 'lmroman', '思源宋体 CN'; /* display: flex; */ letter-spacing: 0.05em; text-indent: 2em; margin: 0; padding: 0; font-size: 1em; font-weight: 400; line-height: 1.6em; } .md-content > .md-typeset h6 { font-feature-settings: 'halt'; text-align: justify; font-family: 'lmroman', '思源宋体 CN'; /* display: flex; */ letter-spacing: 0.05em; text-indent: 2em; margin: 0; padding: 0; font-size: 1em; font-weight: 400; line-height: 1.6em; } 人們普遍認為，太史公司馬遷慧眼識珠，在封建王朝崇本逐末、重農抑商的主流政策下，認識到了工商業者的重要價值，以《貨殖列傳》篇開啟了 “為商賈立傳” 的書史先例。然而，當代人們重在分析其經濟思想價值，而往往忽視了其中蘊含的語言文字養料。筆者在細讀《貨殖列傳》的過程中，發現 “小人富，以適其力” 句中動詞 “適”，古人未解，今注存疑。筆者嘗試以此為錨，對 “適” 字實詞詞義引申發展脈絡進行梳理，並基於梳理結果，嘗試對該句 “適” 字的意義與用法作出回應。 筆者在閱讀時參考了韓兆琦《史記三全本》和張大可《史記新證》二書。韓氏和張氏對 “適” 字有迥異的解釋。為便於閱讀，筆者將原文選段呈現如下： 故曰：「倉廩實而知禮節，衣食足而知榮辱。」禮生於有而廢於無。故君子富，好行其德；小人富，以適其力。淵深而魚生之，山深而獸往之，人富而仁義附焉。富者得勢益彰…… 韓兆琦先生對該句的注解如下： ④小人富以適其力：適其力，謂肆意逞強，橫行於社會。適，放縱，逞慾。 張大可先生對該句的注解如下： ④適其力：樂用其力於公事。 可見，對於該句的理解分歧，正是在 “適” 字。 筆者嘗試採用 “概念要素分析法” 梳理詞義引申發展線索。鑒於概念要素分析法的局限性，下面的分析僅局限在實詞 “適” 的領域。我們接下來明確實詞 “適” 字諸多義位間的關聯。首先，我們抓住 “適” 字的基本意義。《說文》“適” 條：“之也。从辵，啻聲。適，宋魯語。”《漢語大詞典》：“適（shì），去，往”。 蔣紹愚（2007）先生認為打擊（Striking）、位移（Moving）、飲食（Eating and Drinking）和觀看（Looking）等是人類共同的概念場（域），“位移” 是位移概念場的核心要素。“適” 本義 “去，往”，顯然含有 “位移” 這一概念要素。由於概念場中下位詞包含上位詞的全部概念要素，因此，可以判斷 “適” 作 “去、往” 解時屬於位移概念場。 概念場是一個層級結構（hierarchical structure）（蔣紹愚，2006）。位移概念場的部分層級結構如下： 1234567graph位移--&gt;物的位移位移--&gt;人的位移位移--&gt;人使物位移人的位移--&gt;從別的地方位移到說話人所在的地方--&gt;來人的位移--&gt;從所在地位移到別的地方--&gt;往,徂,之,適,如,赴,造,詣 此外，我們看以下的語料： ～子之館。（《詩・鄭風・緇衣》） 今～南畝。（《甫田》） 赤之～齊也。（《論語・雍也》） 子～衛。（《論語・子路》） ～莽蒼者三湌而反，腹猶果然。（《莊子・逍遙遊》） 按《故訓匯纂》載，以上諸例古人皆訓 “往也”。位於本義義位的 “適” 後一般跟一個賓語，即 “適” 與兩個名詞性成分發生聯繫，按朱德熙（1978）先生的觀點，此時的 “適” 是二價動詞。筆者認為，與 “適” 這一動詞發生關係的兩個名詞性成分，從語義角色的角度看，作 “適” 主語的，是 “適” 這一動作的發出者；作 “適” 賓語的，是 “適” 這一動作的終點。此外，在 “人的位移” 概念場下，“適” 與 “來” 的區別，不僅在於 “終點” 概念要素不同，與 “起點” 概念要素也相關。基於對 “適” 的配價分析和對其所處概念場的層級分析，我們得到，與 “適” 處於同層級概念場的成員具有以下共同的概念要素： 核心要素 (K) 動作發出者 (L) 起點 (S) 終點 (T) 位移 人 所在地 別的地方 綜合上述概念要素，我們就得到對 “適” 本義的定義式解釋 —— 人從所在地位移到別的地方。 下面梳理實詞 “適” 的意義演變。在 “適” 字詞義演變的過程中發生了詞性的變化。從詞性虛實的角度，我們把 “適” 分為兩個詞｛適 1｝｛適 2｝，以｛適 1｝代表實詞 “適”。每個詞下又分若干義位，用［適 1A］［適 1B］等表示。 顯然：｛適 1｝人（使自己）從所在地位移到別的地方及其直接引申義 ［適 1A］去，往。 核心要素 (K) 動作發出者 (L) 起點 (S) 終點 (T) 位移 人 所在地 別的地方 這是 “適” 的字本義，也是 “適 1” 的本義，是 “適 1” 被使用最多的義位。例如： 子適衛，冉有僕。子曰：「庶矣哉！」冉有曰：「既庶矣。又何加焉？」曰：「富之。」曰：「既富矣，又何加焉？」曰：「教之。」（《論語・子路》） 大師摯適齊，亞飯干適楚，三飯繚適蔡，四飯缺適秦。鼓方叔入於河，播鼗武入於漢，少師陽、擊磬襄，入於海。（《論語・微子》） 大夫七十而致事。若不得謝，則必賜之几杖，行役以婦人。適四方，乘安車。自稱曰老夫，於其國則稱名；越國而問焉，必告之以其制。（《禮記・曲禮上》） 孔子南適楚，厄於陳蔡之間，七日不火食，藜羹不糝，弟子皆有飢色。（《荀子・宥坐》） 太史公曰：吾適楚，觀春申君故城，宮室盛矣哉！（《史記・春申君列傳》） ［適 1B］歸。 核心要素 (K) 動作發出者 (L) 起點 (S) 終點 (T) 位移 人 所在地 結局，在傳統文化中有時也指 “原來的地方” ［適 1B］相比於［適 1A］更強調了終點的 “終了、結局” 義。如： 好惡不愆，民知所適，事無不濟。（《左傳・昭公十五年》，杜預注：“適，歸也。” 孔穎達疏：“言皆知歸於善也。”） 圓景早已滿，佳人殊未適。（南朝宋謝靈運《南樓中望所遲客》） 兩處的 “適” 是比較明顯的 “歸” 的義位，分別對應變體 “歸向” 和 “回歸”。 ［適 1C］女子出嫁。 核心要素 (K) 動作發出者 (L) 起點 (S) 終點 (T) 位移 女子 所在地 夫家 基於［適 1B］義位，通過限定動作發出者為女性、終點 —— 結局為夫家，得到［適 1C］義位。《說文》載 “女子嫁曰適人”，可見確有其意。如： 女自房觀之，曰：“子皙信美矣，抑子南夫也。夫夫婦婦，所謂順也。” 適子南氏。（《左傳・昭公元年》） 奉光有女年十餘歲，每當適人，所當適輒死，故久不行。及宣帝即位，召入後宫，稍進爲婕妤。（《漢書・外戚傳》） 女子十五許嫁，有適人之道。（《孔子家語・本命》） 始適還家門。（《孔雀東南飛》） 接下來，我們重點討論［適 1D］義位的形成與表現。［適 1D］合，一致，和諧；符合，適合。 核心要素 (K) 動作發出者 (L) 起點 (S) 終點 (T) 變化 / 狀態 某實體 — 該實體的某要素同 $x$ 一致的狀態 引申路徑《現代漢語詞典》：“符合，动词，（数量、形状、情节等）相合。” 因此我們得到了上述表格。然而，對比［適 1D］與上面三個義位，表格中的五個概念要素，看起來都發生了變化。它們之間是否存在關聯呢？ 實際上，對於 “位移”、“人”、“別的地方” 這三個概念要素，還可以再進一步分析： 位移 = [空間方面的] + [變化]； “人” 的上位概念域是 “動物”，“動物” 的上位概念域是 “生命體”，“生命體” 的上位概念域是 “實體”，即：人 = [a] + [b] + … + [實體]； “狀態” 是 “處所” 的抽象化。 因此，［適 1A］［適 1B］與［適 1D］實際上在核心要素、受事對象和終點上都有部分相同。這形成了［適 1A］［適 1D］/［適 1B］［適 1D］義位之間的關聯，為這樣的引申提供了基礎。[^1] [^1]: 實際上，在 “適” 字的整個引申發展系統中，這樣的一步引申是變化相對大的。我們可以為其單列一個詞。但蔣紹愚（2005）：“…… 在本章第一节中已经说过，相关而且相近的意义应该是一个词的不同义位，无关的或者是相距甚远的应该算两个词。但是在‘远’、‘近’之间有时也难以划出绝对的界线。汉语词汇史因为是研究词义的历史发展的，所以，我们不妨把 “词” 的界线放宽些，比如‘投’的‘到临’义，可以不看做另一个词，而看做和上六个义位一起，构成同一个词的第七个义位。” 因此本文也暫且將此看做義位而非詞。 那麼，［適 1D］究竟是由［適 1A］還是［適 1B］引申而來的呢？ 段玉裁《說文解字注》：“適，之也…… 此不曰往而曰之，許意葢以 “之” 與 “往” 稍別。逝、徂、往，自發動言之；適，自所到言之。故變卦曰之卦，女子嫁曰適人。” 按照段玉裁的解讀，“適” 更強調 “所到”，即有位移結束的意味。 我们看下面的例子： （1）孔子時其亡也，而往拜之，遇諸塗。（《論語・陽貨》） （2）今燕虐其民，王往而征之，民以為將拯己於水火之中也，簞食壺漿，以迎王師。（《孟子・梁惠王下》） （3）戒之曰：“往之女家，必敬必戒，無違夫子！”（《孟子・滕文公下》） （4）逝將去汝，適彼樂土；樂土樂土，爰得我所。（《詩・國風・魏風》） （5）孔子適楚，楚狂接輿遊其門曰：「鳳兮鳳兮，何如德之衰也！來世不可待，往世不可追也。天下有道，聖人成焉；天下無道，聖人生焉。方今之時，僅免刑焉。福輕乎羽，莫之知載；禍重乎地，莫之知避。已乎已乎，臨人以德！殆乎殆乎，畫地而趨！迷陽迷陽，無傷吾行！吾行卻曲，無傷吾足！」（《莊子》） （6）十五年，使子服景伯、子貢為介，適齊，齊歸我侵地。田常初相，欲親諸侯。（《史記・魯周公世家》） （7）太史公曰：吾適楚，觀春申君故城，宮室盛矣哉！（《史記・春申君列傳》） 首先，儘管區別有時並不嚴格，但 “適” 後一般直接開始陳述位移結束以後發生的事情（如（4）～（7））；而 “往” 後不僅可以陳述位移過程中發生的事情（如（1）），其本身也可以尚未開始，用於一種 “對將來的假設” 的語境中（如（2）（3）），或前加 “不” 字表示不可能開始（不往），“適” 字幾乎沒有這樣的用法。拙見以為 “逝、徂、往” 與 “適、之” 之別，相當於英語 “go” 與 “get” 之別。在 “（1）I’ll go to the cinema at 5” 和 “（2）I’ll get to the cinema at 5” 中，（2）句更強調 “在 5 點鐘到達”；而（1）句不僅寬泛地看沒有到達義、嚴格地看可能還有 “出發” 義。“適” 與 “往” 在這方面的微殊，可以證明 “適” 更強調 “所到”，而不強調起點要素。 其次，筆者觀察到，“適” 基本不與強調起點要素的介賓結構（如 “自某適” 結構）相配。值得注意的是，在先秦兩漢古代漢語中，“去 S 適 T” 結構不鮮。如： 逝將去汝，適彼樂土；樂土樂土，爰得我所。（《詩・國風・魏風》） 彼其人苟壹，則其土地奚去我而適它？（《荀子・王霸》） 夫自中行衍皆嬴姓也，中衍人面鳥喙，降佐殷帝太戊及周天子，皆有明德，下及幽厲無道，而叔帶去周適晉，事先君文侯，至於成公，世有立功，未嘗有絕祀。（《說苑・復恩》） 去鄭，適衛。（《史記・吳太伯世家》） 下及幽厲無道，而叔帶去周適晉，事先君文侯，至于成公，世有立功，未嘗絕祀。（《史記・趙世家》） 孔子去曹適宋，與弟子習禮大樹下。（《史記・孔子世家》） 這裡需要使用 “去 S” 這一動賓結構，構成與 “適 T” 相平等的語法地位，來強調動作行為的起點，這也是證明 “適” 強調終點要素的有力依據。 此外，考察 “適” 處於［適 1C］女子出嫁義位時的語用，按《古辭辨》觀點，“適” 作 “女子出嫁” 解時，一般以帶賓語（即終點要素）“人” 的短語形式出現，形成較為穩定的結構；同時也基本不與強調起點要素的介賓結構搭配。 如果我們認為，與［適 1A］相關的［適 1D］繼承了［適 1A］“自所到言之” 的異質性，那麼［適 1D］的起點要素就可能被弱化消失。由於［適 1B］相比於［適 1A］更強調終點要素，我們認為，［適 1B］位於從［適 1A］到［適 1D］的引申路線內，即［適 1A］［適 1B］和［適 1D］是共線的；相應地，從強調的強弱差異角度，我們自然可以認為［適 1D］是由［適 1B］直接引申而來的。 12graph LR適1A--&gt;適1B--&gt;適1D 表現［適 1D］的起點要素被弱化乃至消失，進一步地，由於只剩下終點要素，［適 1D］的核心要素有可能從動態的 “變化” 演變成靜態的 “狀態”。然而，由於古漢語中常常把動作和動作的結果綜合在一起（蔣紹愚，2006），“變化” 與 “狀態” 的界限是模糊的。我們得到了［適 1D］義位的三個義位變體： （1）以變化为核心要素，同时还強調終點的狀態。後跟 “適” 的目標 / 目的，進一步明確 “終點” 要素（特別是 $x$ 的內容）。可以譯作 “適合，滿足，順從，愉悅” 等。如： 太子日造門下，供太牢具，異物閒進，車騎美女恣荊軻所欲，以順適其意。（《史記・刺客列傳》） 殺子以適君，非人情，不可。（《史記・齊太公世家》） 快意當前，適觀而已矣。（《史記・李斯列傳》） （2）核心要素為狀態，隱含變化到終點狀態的變化，可以譯作 “相合”，一般有多個名詞性成分作主語，$x$ 可理解為某實體以外的其他實體。如 能以一治天下者，寒暑適，風雨時，爲聖人。（《呂氏春秋・大樂》，高誘注） （3）核心要素為狀態，不再隱含上述變化，而專一強調該狀態，可以譯作 “合，合適；和，和諧；恰當；齊等”。如： 陳嬰者，故東陽令史，居縣中，素信謹，稱為長者。東陽少年殺其令，相聚數千人，欲置長，無適用，乃請陳嬰。（《史記・項羽本紀》） 兵之勝，從於適。（《管子・白心》，尹知章注） 是以君臣朝廷尊卑貴賤之序，下及黎庶車輿衣服宮室飲食嫁娶喪祭之分，事有宜適，物有節文。（《史記・禮書》） 如果後跟的是 “適” 的受事對象（明確 “受事對象” 要素），筆者認為這是變體 3 的使動用法，來表示 “使賓語所代表的事物具有‘適（於 $x$）’這一性質” 的動作，可以譯作 “使…… 合適（於 $x$）”。如： 所謂氣者，當調飲食，擇晏日，車步廣志，以適筋骨肉血脈，以瀉氣。（《史記・扁鵲倉公列傳》） 吸新吐故以練藏，專意積精以適神。（《漢書・王吉傳》，顏師古注） 故聖人之制事也，能節宮室、適車輿以實藏，則國必富、位必尊。（《管子・禁藏》，尹知章注：“不費於宮室車輿，則庫藏自實也。”） 欲爲其地，必適其賜，不適其賜，亂人求益，彼求我予，假仇人斧。（《韓非子・揚權》，兪樾《諸子平議・韓非子》：“必適其賜者，必節其賜也。”） 現代漢語中已經使用 “調節”“調適” 等詞來表示這一動作，因此將其譯作前述雙音節動詞亦可。如果通過上下文能夠明確 “適” 的起點為 “某要素（相較於 $x$ ）處於過分的狀態”，則還可以譯作 “節制”。 然而需要注意的是，由於並不像變體 1、變體 2 這樣對 $x$ 有進一步的明確，因此，在翻譯的過程中，如果 $x$ 是偏離缺省值（①在一些情況下，語言使用者的價值觀可以定義 $x$ 的缺省值；②如果適後跟多個名詞性成分的組合作賓語，則 $x$ 的情況與變體 2 類似）的，或通過上下文較難明確的，筆者認為有必要使用 “使（賓語）符合於 $x$” 或在 “調適（賓語）” 後添加 “使之符合於 $x$” 的譯法，來對 $x$ 的內容進行明確，以更好地銜接上下文。 《故訓匯纂》載王先謙集解引郝懿行曰：“適者，善也。凡物調適謂之適，得意便安亦謂之適，皆善之意。故《廣韻》云：‘適，善也。’” 可見，古人亦認為 “調適”、“和諧”、“安適” 等義之間的關係比較緊密，字典單列義項雖可，但略顯冗餘。 至此，我們完成了對實詞 “適” 引申發展脈絡的梳理。 除此之外，虛詞｛適 2｝以（時間層面）合，巧為基本義，按《漢語大詞典》，設有四個義項：①巧合，正好；②剛才，方才；③偶然；④如果。由於概念分析法的局限，筆者不再贅述。此外，按《漢語大詞典》，“適” 還通 “啻”（只，僅僅）、通 “擿”（投擲）、用同 “釋”（參見 “適悶”）、通 “謫（讁）”、通 “嫡”、通 “敵”，分別為詞｛適 3｝～｛適 8｝。由於是假借關係，不屬於引申發展的序列；而對與其本字詞義的引申發展梳理，我們也暫不討論。基於上述梳理結果，筆者認為，對於《貨殖列傳》中 “小人富，以適其力” 句，此處 “適” 字適用［適 1D］義位，且在當前上下文應表現為變體 3 的使動用法，解作：使自己的能力適合（禮節）；或，調適自己的能力，使之適合（禮節）。有關韓注、張注，按照筆者上文的引申發展梳理結果，韓注、張注均以 “適” 為［適 1D］變體 3。然而，這樣的觀點難免會使得釋義與上下文脫節嚴重：（1）如果小人富裕之後，還 “肆意逞強，橫行於社會”，那哪是 “衣食足而知榮辱”？韓注必謬。（2）張注為了銜接上下文似乎補充太多，補了謂語 “用、盡”、目的狀語 “於公事”，有失妥當。認為表現為變體 3 的使動用法有如下的合理性：語義理解上：把握住本段的中心論點 —— 倉廩實而知禮節，衣食足而知榮辱。因此，“小人富” 後，一致的對象應當是 “禮節” 一類，即 $x=$ 禮節。君子（有德者）和小人並舉，君子本身有德，富而行其德；小人本身寡德，富而能調適自己的能力（使之符合禮節）。這樣作者觀點是前後一致的，同時翻譯上也更客觀。“小人” 往往是 “君子” 的對立面，而太史公此處是要論證無論是 “小人” 還是 “君子” 富都能知榮辱。對於 “小人”，這樣的觀點是顛覆常人價值觀的。而此處的 “適” 又未明確 $x$ 的內容，對於現代人而言，語義上的省略有些多了，倘若不瞻前顧後，則不能明確 $x$。此處韓、張之所以未能準確翻譯，大概原因如此吧。 可行性上：對《史記》全書共 171 例 “適” 字，採用語料標注的辦法對其釋義進行標注，結果統計如下圖： 適用［適 1D］義位，且表現為變體 3 的情況，與［適 1D］變體 1 的出現頻率相當，仍有一定占比。典型的用例如下： 太子起坐。更適陰陽，但服湯二旬而復故。（《扁鵲倉公列傳》） 所謂氣者，當調飲食，擇晏日，車步廣志，以適筋骨肉血脈，以瀉氣。（《扁鵲倉公列傳》） 四時不和不能調，歲穀不孰不能適。（《日者列傳》）^ 3 根據數據，筆者傾向於認為這個解釋是可行的、合法的。 小結這篇文章中，我們嘗試運用概念要素分析法對 “適” 的引申發展路徑進行了簡要梳理，並根據梳理結果解決了《貨殖列傳》中 “小人富，以適其力” 句 “適” 字釋義問題。對於引申發展脈絡的梳理，《漢語大詞典》“適” 諸多義項的設置便於初學者使用，有其合理性，但不能真實反映引申發展的步驟和層次，有 “隨句釋義” 之嫌。對於《貨殖列傳》“小人富，以適其力” 句中 “適” 字，我們基於梳理結果，提出了新的看法。筆者認為，從概念要素分析法的角度入手，建構詞義引申發展系統，論證存疑詞義，簡潔明了，說服力強，有助於我們在今後的更好地理解古代漢語的詞彙與詞彙系統。 參考文獻 [1] 朱德熙.“的” 字结构和判断句 (上)[J]. 中国语文,1978,(第 1-4 期). [2] 蒋绍愚著. 古汉语词汇纲要 [M]. 北京：商务印书馆, 2005.09. [3] 蒋绍愚. 汉语词义和词汇系统的历史演变初探 —— 以 “投” 为例 [J]. 北京大学学报 (哲学社会科学版),2006,(第 4 期). [4] 蒋绍愚. 打击义动词的词义分析 [J]. 中国语文,2007,(第 5 期). 附：《漢語大詞典》“適①” 條 ［shì ㄕˋ］［《廣韻》施隻切，入昔，書。］［《廣韻》之石切，入昔，章。］［《廣韻》都歷切，入錫，端。］“啇” 的今字。“適” 的繁體字。1. 去，往。《楚辭・離騷》：“心猶豫而狐疑兮，欲自適而不可。” 王逸注：“適，往也。”《史記・吳太伯世家》：“&lt;季劄&gt; 去鄭，適衛。” 宋蘇軾《石鍾山記》：“元豊七年，六月丁丑，余自齊安舟行適臨汝。” 淸孔尙任《桃花扇・聽稗》：“那太師名摯，他第一個先適了齊。” 魯迅《書信集・致許壽裳》：“君今年奚適?”2. 歸向；歸從。《管子・弟子職》：“拚前而退，聚於戶內，坐板 &lt; 扱&gt; 排之，以葉適己。” 尹知章注：“適己，猶向己也。”《左傳・昭公十五年》：“好惡不愆，民知所適，事無不濟。” 杜預注：“適，歸也。” 孔穎達疏：“言皆知歸於善也。” 南朝宋謝靈運《南樓中望所遲客》詩：“圓景早已滿，佳人殊未適。”3. 女子出嫁。《左傳・昭公元年》：“女自房觀之，曰：‘子皙信美矣，抑子南夫也。夫夫婦婦，所謂順也。’適子南氏。”《玉台新詠・古詩〈爲焦仲卿妻作〉》：“貧賤有此女，始適還家門。” 余冠英注：“適，嫁。始適，言出嫁未久。” 宋蘇軾《劉夫人墓志銘》：“女二人，長適進士虞大蒙，次適承議郞郭逢原。” 淸徐士鑾《宋豔・奇異》：“淮娼嚴楚楚，適鹽商呂省幹。” 魯迅《墳・我之節烈觀》：“直到宋朝，那一班‘業儒’的才說出‘餓死事小失節事大’的話，看見曆史上‘重適’兩個字，便大驚小怪起來。”4. 順從。《韓非子・三守》：“使人臣之欲有言者，不敢不下適近習能人之心。” 洪誠等校注：“適，適從，順應。” 陳奇猷集釋：“適，謂順適其意。”《玉台新詠・古詩〈爲焦仲卿妻作〉》：“處分適兄意，那得自任專?” 余冠英注：“適，順從。”5. 適合，符合。《商君書・畫策》：“由此觀之，神農非高於黃帝也，然其名尊者，以適於時也。” 三國魏劉劭《人物志・材理》：“質性機解，推情原意，能適其變，情理之家也。” 唐韓愈《與鄂州柳中丞書》：“愈誠怯弱，不適於用，聽於下風，竊自增氣。” 淸嚴有禧《漱華隨筆・夾帶懷挾》：“今之時文，徒空言而不適於實用。”6. 節制；調節。《管子・禁藏》：“故聖人之制事也，能節宮室、適車輿以實藏，則國必富、位必尊。” 尹知章注：“不費於宮室車輿，則庫藏自實也。”《韓非子・揚權》：“欲爲其地，必適其賜，不適其賜，亂人求益，彼求我予，假仇人斧。” 兪樾《諸子平議・韓非子》：“必適其賜者，必節其賜也。”《史記・日者列傳》：“四時不和不能調，歲穀不孰不能適。” 司馬貞索隱：“適，猶調也。” 晉葛洪《抱朴子・酒誡》：“然節而宣之，則以養生立功，用之失適，則焚溺而死。”7. 恰當，得當。銀雀山漢墓竹簡《孫臏兵法・兵情》：“弩張柄不正，偏強偏弱而不和，其兩洋 (廂) 之送矢也不壹，矢雖輕重得，前後適，猶不中 &lt;招也&gt;。”《漢書・武帝紀》：“古者，諸侯貢士，壹適謂之好德，再適謂之賢賢，三適謂之有功，乃加九錫。” 顏師古注引服虔曰：“適，得其人。”《尙書大傳》卷二：“一適謂之攸好德，再適謂之賢賢，三適謂之有功。” 鄭玄注：“適猶得也。”《後漢書・匈奴傳》：“報答之辭，令必有適。” 李賢注：“適猶所也，言報答之辭必令得所也。”《資治通鑑・漢光武帝建武二十八年》引此文，胡三省注曰：“余謂適，當也，言報答之辭必有當乎事情也。” 晉葛洪《抱朴子・審舉》：“古者諸侯貢士，適者謂之有功，有功者，增班進爵；貢士不適者，謂之有過，有過者，黜位削地。”8. 齊等。《呂氏春秋・處方》：“韓昭釐侯出弋，靷偏緩…… 至舍，昭釐侯射鳥，其右攝其一靷適之。” 高誘注：“適，猶等也。”《漢書・循吏傳・黃霸》：“&lt;黃霸&gt; 坐發民治馳道不先以聞，又發騎士詣北軍馬不適士，劾乏軍興，連貶秩。” 顏師古注引孟康曰：“關西人謂補滿爲適。馬少士多，不相補滿也。”9. 悅樂，滿足。《詩・衛風・伯兮》：“豈無膏沫? 誰適爲容!” 馬瑞辰通釋：“《一切經音義》卷六引《三蒼》：‘適，悅也。’此適字，正當訓悅。女爲悅己者容，夫不在，故曰‘誰適爲容’，即言誰悅爲容也。” 余冠英注：“適，悅也。誰適爲容，言修飾容貌爲了取悅誰呢?”《史記・張儀列傳》：“割楚而益梁，虧楚而適秦，嫁禍安國，此善事也。”《漢書・賈山傳》：“秦王貪狼暴虐，殘賊天下，窮困萬民，以適其欲也。” 顏師古注：“適，快也。”《資治通鑑・陳武帝永定二年》：“帝褻黷之遊，徧於宗戚，所往留連，唯至常山第，多無適而去。” 胡三省注：“適，歡極也。” 金張宇《云溪秋泛圖》詩：“胡爲厭山瞰芳渚，岸草汀花適幽趣。”10. 和順，順適。《文選・宋玉〈神女賦〉》：“性和適，官侍旁，順序卑，調心腸。” 呂延濟注：“言性靈和適，心腸調順，宜侍君旁。”《呂氏春秋・大樂》：“能以一治天下者，寒暑適，風雨時，爲聖人。” 高誘注：“適，和也。” 唐韓愈《息國夫人墓志銘》：“居尊卑間，無不順適。”11. 安逸，閑適。《楚辭・九辯》：“堯舜皆有所舉任兮，故高枕而自適。” 王逸注：“安臥垂拱，萬國治也。” 宋沈作喆《寓簡》卷六：“以此知能自適其適者，不管其他閑事也。” 淸魏源《天台紀遊》詩之六：“萬里水雲身，到此甫一適。”12. 舒適，和暢。《墨子・辭過》：“故聖人之爲衣服，適身體和肌膚而足矣。”《漢書・王吉傳》：“吸新吐故以練臧，專意積精以適神，於以養身，豈不長哉!” 顏師古注：“適，和也。” 唐韓愈《唐故河南令張君墓志銘》：“不得已就官，數月大不適，即以病辭免。” 宋范成大《問天醫賦》：“百骸九竅，無一得適。” 巴金《探索集・長崎的夢》：“聽說他身體不適，不能見客。”13. 善，美好。《荀子・法行》：“瑕適幷見，情也。” 楊倞注：“適，玉之美澤調適之處也。” 王先謙集解引郝懿行曰：“適者，善也。凡物調適謂之適，得意便安亦謂之適，皆善之意。故《廣韻》云：‘適，善也。’” 一說，指疵病。王念孫《讀書雜志・荀子八》：“適讀爲謫。謫亦瑕也。《老子》曰‘善言無瑕謫’是也。《管子・水地篇》：‘瑕適皆見，精也。’尹知章注：‘瑕適，玉病也。’”14. 辟領。古喪服之領。《儀禮・喪服》：“負廣出於適寸。適博四寸，出於衰。” 鄭玄注：“適，辟領也。” 李如圭集釋：“衣領當項處，左右各開四寸，向外辟厭之，是謂辟領。” 淸夏炘《學禮管釋・釋適上》“適之制，與衣殊，材前之衰，後之負版，皆繫於適。先著衣訖，乃始著適。適謂之辟領。辟者，偏也，謂領偏向旁開也。今世小兒衣領，猶有右旁開縫者，其古適之遺制與!” 一說，“適” 是橫接之旁幅，與辟領有別。淸毛奇齡《喪禮吾說篇・服制說》：“其開領處將領隙四寸外屈而厭於項之兩旁，謂之辟領…… 而於是又橫接二幅，謂之適。夫適者，豈非以旁幅之猶近身者乎? 舊注謂辟領爲適，則領在項間未能橫出於衰也。謂適爲辟領，則適當兩肩不能開領。”15. 遇。《文選・班彪〈王命論〉》：“世俗見高祖興於布衣，不達其故，以爲適遭暴亂，得奮其劍。” 李善注：“適，遇也。” 漢蔡邕《傷故栗賦》：“適禍賊之災人，嗟夭折以摧傷。”16. 是，則，即是。《荀子・王霸》：“孔子曰：審我所以適人，適人之所以來我也。” 王引之《經傳釋詞》卷九：“上適字訓爲往，下適字訓爲是。言我之所以往，即是人之所以來，不可不審也。” 漢劉歆《與揚雄求方言書》：“今聖朝留心典誥，發精於殊語，欲以驗考四方之事，不勞戎馬高車之使，坐知傜俗，適子雲攘意之秋也。” 王引之《經傳釋詞》卷九：“言是子雲攘意之秋也。” 唐韓愈《唐故河南令張君墓志銘》：“&lt; 張 &gt; 改河南令，而河南尹適君平生所不好者。”17. 正好，恰巧。《左傳・昭公十七年》：“我高祖少皞摯之立也，鳳鳥適至。”《後漢書・班超傳》：“會徐幹適至，超遂與幹擊番辰，大破之。”《魏書・傅永傳》：“適上南岸，賊軍亦至。” 淸兪樾《春在堂隨筆》卷一：“適徐誠庵大令本立來，與之審視。” 魯迅《書信集・致黃源》：“《譯文》稿剛寫好，因爲適有便人，即帶上。”18. 偶然。《韓非子・外儲說右下》：“吾釋勢與民相收，若是，吾適不愛，而民因不爲我用也，故遂絶愛道也。” 洪誠等校注：“適，偶然。” 唐李白《竄夜郞於烏江留別宗十六璟》詩：“適遭雲羅解，翻謫夜郞悲。” 宋范成大《時敘火後意不釋然作詩解之》：“浮生適來且適去，況此茅屋三間餘。” 傅尃《題自書精神一到何事不成橫卷》詩：“適生適死何足論，精神長在無時滅。”19. 剛才，方才。《漢書・賈誼傳》：“陛下之臣雖有悍如馮敬者，適啓其口，匕首已陷其匈矣。” 顏師古注：“始欲發言節制諸侯王，則爲刺客所殺。”《二刻拍案驚奇》卷九：“你適在那邊書房裏來，有何說話，笑嘻嘻的走來?”《紅樓夢》第一回：“適聞僊師所談因果，實是人世罕聞者。”20. 連詞。如果，假若。表示假設關系。《韓非子・內儲說下》：“王適有言，必亟聽從王言。” 洪誠等校注：“適，如果。”《後漢書・逸民傳序》：“故蒙恥之賓，屢黜不去其國；蹈海之節，千乘莫移其情。適使矯易去就，則不能相爲矣。” 唐王昌齡《淇上酬薛據兼寄郭微》詩：“吾謀適可用，天道豈遼廓!”21. 通 “擿”。投擲。《詩・邶風・北門》：“王事適我，政事一埤益我。” 馬瑞辰通釋：“適當爲擿之渻借。《說文》、《廣雅》幷曰：‘投，擿也。’《說文》‘擿’字注：‘一曰投也。’古書投擲字多作擿。擿我，猶投我也，正與二章箋訓敦爲投擲同義。” 高亨注：“適，借爲擿，投擲。”22. 通 “啻”。副詞。但，僅僅。《孟子・告子下》：“飲食之人無有失也，則口腹豈適爲尺寸之膚哉?” 趙岐注：“口腹豈但爲肥長尺寸之膚邪?” 王引之《經傳釋詞》卷九：“適與啻同，故趙注曰：‘口腹豈但爲肥長尺寸之膚邪?’但字正釋適字。”《戰國策・秦策二》：“疑臣者不適三人，臣恐王之爲臣投杼也。” 高誘注：“適音翅。” 鮑彪注：“適啻同。” 諸祖耿集注引黃式三曰：“適、啻，古聲同，止也。《史》作特。” 南朝宋鮑照《重與世子啟》：“僕以常人，所蒙隆厚，久應知退，非適今日。” 淸戴名世《春西狩獲麟解》：“必假此以爲聖人重而震而驚之，則欲大聖人而適以小聖人矣。”23. 用同 “釋”。參見 “適悶”。","link":"/2023/12/29/%E2%80%9C%E9%81%A9%E2%80%9D%E5%AF%A6%E8%A9%9E%E8%A9%9E%E7%BE%A9%E5%BC%95%E7%94%B3%E7%99%BC%E5%B1%95%E8%84%88%E7%B5%A1%E6%A2%B3%E7%90%86/"}],"tags":[{"name":"中文信息处理史","slug":"中文信息处理史","link":"/tags/%E4%B8%AD%E6%96%87%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E5%8F%B2/"},{"name":"一年半载","slug":"一年半载","link":"/tags/%E4%B8%80%E5%B9%B4%E5%8D%8A%E8%BD%BD/"},{"name":"古代漢語","slug":"古代漢語","link":"/tags/%E5%8F%A4%E4%BB%A3%E6%BC%A2%E8%AA%9E/"}],"categories":[{"name":"Something Interesting","slug":"Something-Interesting","link":"/categories/Something-Interesting/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"密友来稿","slug":"密友来稿","link":"/categories/%E5%AF%86%E5%8F%8B%E6%9D%A5%E7%A8%BF/"},{"name":"生产力","slug":"生产力","link":"/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/"}],"pages":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hello-world.html"},{"title":"关于","text":"Whoami 關於我o0o0o0o @ PKU 本科在讀，來自中國大陸。 位於上古漢語和算法之間。 因此，對於本網站出現的簡中、正體、英文與代碼混雜的情況，我感到非常抱歉。 Interests 興趣 NLP, AI, Web Frontend, System (esp. Linux) &amp; Network Computer Science, Linguistic （esp. phonetics &amp; syntax of ancient Chinese） Also in Minecraft, Pure Music, Traditional Chinese, Riding, Reading, Photographing. Skills 技能 Python/C++ for coding HTML &amp; CSS for entertaining (x) Contact Me 聯繫方式E-mail | lz_liang (AT) outlook.com 網站更新情況 UTC+8 BJT 2024/5/10: 將本網站遷移至 Hexo，使用 Hexo-Amazing 主題。對主題源碼進行了修改，刪除了花哨的元素，包括字體重置、取消“一言”、取消頭像旋轉、取消“看板娘”等。採用 hexo-generator-topindex 加入了置頂功能（目前嘗試唯一無 Bug），使用 hexo-markmap 加入了思維導圖功能。 UTC+8 BJT 2024/3/10: 解決了手機佈局下 nav 中定義日期的對齊問題；tags 頁面無法使用 nav 的問題已解決；讓首頁背景變成更美麗的照片，並優化了首頁與其他頁面的互動邏輯；簡陋地添加了一些友情鏈接。然而，按照日期排序的問題尚未解決；此外，希望友情鏈接添加更簡單、更自動，格式更美觀；還希望讓首頁的互動性更強一些（已經用 gif 背景實現首頁動起來了，對於圖集的話還需使用一些 JS Scripts，尚未實現）。 UTC+8 BJT 2024/3/9: 精簡了網站的設計——取消了首頁的 Blog，修改了 tags 使其能夠顯示每個頁面的日期（但尚未做到按照日期排序，包括 nav 部分），修改了 overrides 使得每個 Page 都能顯示已定義的日期與作者（但響應式佈局——手機佈局仍然有對齊問題）。tags 頁面無法使用 nav 的問題也沒有解決。 UTC+8 BJT 2024/3/3: 客製本網站的基本樣式並敲定 UTC+8 BJT 2024/2/29: 將本网站部署到私有雲服務器 UTC+8 BJT 2024/2/16: 用 MkDocs 重置本网站 Operator’s Memo 建站號這個網站可能什麼都會有。總體上，我還是希望把這個網站作為自己寫作記錄的一個平台，把它當作一本無窮大的筆記本。因此這個網站的版式是相對文藝的，網站的內容也採用了更有文化底蘊的正體字來呈現。從記錄的目的出發，我可能會在此處不定期更新一些生活隨筆 / 讀書筆記等文章，當然歡迎諸賢斧正。 除此之外，拜倒於一個 “Website” 的強大力量，我還十分願意把諸多學習資料上傳於此，也歡迎大家取用。 2024 年 1 月 6 日，其實還在期末考試期。但在整理期末考試筆記的過程中，抱著讓筆記更加賞心悅目的宗旨，我時常爆改 Typora 的 CSS 主題和輸出，並且在碼 Markdown 的過程中又頻繁地借 HTML 助力。作為一個排印愛好者，雖然 HTML 的中文排版有諸多問題，但我還是歎服於其功能之強大。網站不也是用 HTML 編寫的嘛！我逐漸按耐不住擁有一個網站的衝動。於是便乘興而發，白手起家，魔改手頭上現有的文字材料，讓腦子裡不多的 Thinking 與強大的搜索引擎與 AI 結合，從 1 月 6 日的晚上開始，到翌日夜分讓網站基本成了形。 我下一步的想法，一是多把寒假裡的感悟與收穫，放到網站上來；二是鑒於寒假回中學看望的行程，在此處盡力搜羅陳列應試資料、招考時訊，以裨益後學。倘若那日審美疲勞，又適得閒暇，將此站重新修葺一番，亦未可知。","link":"/about.html"}]}